1
00:00:00,400 --> 00:00:00,960
Hey, everyone.

2
00:00:01,040 --> 00:00:05,360
Welcome to our Azure Storage module of the V3 Masterclass.

3
00:00:06,000 --> 00:00:16,240
And this module is really all focused around the functionality of the Azure Storage account, this building block that many other things in Azure actually build on.

4
00:00:16,640 --> 00:00:29,520
So we look at the capabilities of Azure Storage, some of the capabilities of virtual machines, which again are a fundamental building block of what many of the other services in Azure are built on, and then some of the storage tools.

5
00:00:31,280 --> 00:00:40,240
Now, when we go ahead and think about the types of storage that we have in Azure, we have various considerations.

6
00:00:40,720 --> 00:00:45,440
And we'll talk about things like durability, that's the ability to preserve data over time.

7
00:00:45,440 --> 00:00:49,000
Latency, how long some certain operation takes.

8
00:00:49,000 --> 00:00:50,320
And remember, latency

9
00:00:50,720 --> 00:00:59,360
is a function of both maybe the distance between me doing the operation and the actual storage, and then the storage itself doing that operation.

10
00:00:59,680 --> 00:01:04,800
In the old days of hard disk drives, you had this seek time as the head had to move to the right spot.

11
00:01:04,960 --> 00:01:10,400
With SSDs, there is no seek time, but it still takes an element of time to perform operations.

12
00:01:10,880 --> 00:01:13,320
And then we talk about things like the structure of the data, et cetera.

13
00:01:13,600 --> 00:01:16,240
So different workloads

14
00:01:16,640 --> 00:01:21,520
have different needs for different types of storage, both ephemeral and durable.

15
00:01:21,520 --> 00:01:26,640
So when we think about ephemeral, it's kind of, it's there for a moment in time.

16
00:01:26,640 --> 00:01:28,400
It's temporary, it's volatile.

17
00:01:28,720 --> 00:01:31,440
This could be I'm using it for some cache type purpose.

18
00:01:31,920 --> 00:01:35,760
It might be something I just use, maybe store a page file on.

19
00:01:36,320 --> 00:01:42,960
But if I lose power in whatever compute workload I have, I would lose the content of that.

20
00:01:43,480 --> 00:01:45,400
When I think about durable, it's persistent.

21
00:01:45,400 --> 00:01:47,040
This will be stuff I want to keep.

22
00:01:47,280 --> 00:01:52,640
It has to be stored on some type of long-term media, typically a disk, but maybe even tape.

23
00:01:53,760 --> 00:02:03,840
Now, there are various types of data available that vary greatly depending on what my application needs from that data.

24
00:02:04,960 --> 00:02:11,520
So if I think for a second about the various types of data.

25
00:02:14,160 --> 00:02:18,240
Now one of the things we commonly talk about is unstructured.

26
00:02:18,800 --> 00:02:24,480
So if I have unstructured, this could be something like, hey, I need to store a media file.

27
00:02:25,200 --> 00:02:33,840
It could be an image, it could be a video, just some unstructured piece of data.

28
00:02:34,000 --> 00:02:36,280
So really I could store anything there.

29
00:02:36,280 --> 00:02:38,000
It could be a binary, for example.

30
00:02:38,840 --> 00:02:40,720
And then we think about structured.

31
00:02:42,440 --> 00:02:49,120
And when we think about structured, we're typically thinking about a database, because this would have some schema.

32
00:02:49,440 --> 00:03:01,040
Now, the schema describes what are the various tables we may have, what are the columns, are the attributes of the data, and what is the type of that data?

33
00:03:01,440 --> 00:03:04,480
Is it a text field that's 16 characters long?

34
00:03:04,480 --> 00:03:06,160
Is it a floating point?

35
00:03:06,480 --> 00:03:07,840
Is it a binary?

36
00:03:08,080 --> 00:03:10,280
So you're going to have this fixed schema.

37
00:03:11,320 --> 00:03:18,400
And then the data we put into a particular table has to adhere to that schema.

38
00:03:18,560 --> 00:03:20,160
So it's very rigid format.

39
00:03:21,000 --> 00:03:26,400
And we'll see that a lot in relational databases where we will normalize the data.

40
00:03:26,640 --> 00:03:29,320
So we'll be very efficient with how we store that data.

41
00:03:29,680 --> 00:03:32,560
We'll have relationships between different tables.

42
00:03:32,560 --> 00:03:34,160
We might have foreign keys.

43
00:03:34,560 --> 00:03:42,000
So this particular element within a database, this record relates to another record in a different table.

44
00:03:42,000 --> 00:03:44,600
So it lets us get very efficient with how we store the data.

45
00:03:44,600 --> 00:03:47,520
And then we have documents.

46
00:03:47,520 --> 00:03:49,120
We think about semi-structured.

47
00:03:49,600 --> 00:03:52,320
And this is often self-describing.

48
00:03:52,800 --> 00:03:55,840
So there isn't a traditional schema.

49
00:03:57,040 --> 00:04:01,280
But what we'll have is something like an XML file or a JSON file.

50
00:04:01,600 --> 00:04:10,240
So it describes its own structure within it, but we can have a mixture of different structures within a particular document.

51
00:04:11,120 --> 00:04:16,480
So these are very common types of data that we're going to see today.

52
00:04:17,280 --> 00:04:22,720
Now, another thing we might see as part of these is we need different capabilities.

53
00:04:22,720 --> 00:04:25,600
So for example, indexing in a relational database

54
00:04:25,920 --> 00:04:32,480
is really important, maybe even in that semi-structured inside documents, because I want to be able to go and interact with a certain record.

55
00:04:32,480 --> 00:04:40,800
And if I have a huge amount of data, I don't want to have to trawl through and find the particular record I care about.

56
00:04:41,360 --> 00:04:52,800
So we can have one or more indexes that make it very easy to go and find certain records based on the particular columns, the elements that we have chosen to be indexed and then

57
00:04:53,520 --> 00:04:55,600
easy to very quickly interact with.

58
00:04:56,160 --> 00:04:57,520
We may want snapshots.

59
00:04:58,400 --> 00:05:02,000
The idea that we can take a certain point in time of the data.

60
00:05:02,240 --> 00:05:10,880
I may need it to be able to replicate between maybe different regions, different instances, on-premises, to the cloud, whatever that may be.

61
00:05:10,880 --> 00:05:18,680
And then we'll also have different types of API, application program interfaces, ways one application can talk to our data.

62
00:05:18,680 --> 00:05:21,200
There may be different protocols we want to support.

63
00:05:21,680 --> 00:05:41,120
Block level, where I actually see the blocks on the disk, and then I manage the file system, or we have file base, where I talk to some API and I just deal with the files and the folders, so we have different requirements depending on what I need to do, and there is not one best answer here.

64
00:05:42,320 --> 00:05:50,400
And very typically your application will use multiple different types of storage because you're going to have different requirements for different parts of your application.

65
00:05:50,640 --> 00:05:58,720
So different use cases will lean towards different types of structured data or unstructured or semi-structured.

66
00:05:59,120 --> 00:06:05,360
I might need ephemeral storage, remember that temporary for caching purposes, but then I need durable for the long-term state.

67
00:06:05,360 --> 00:06:07,040
So there's not a best.

68
00:06:07,520 --> 00:06:13,600
it's really going to come down to, well, what is my particular requirement for this element of what I'm trying to solve?

69
00:06:15,360 --> 00:06:17,120
So let's talk about Azure storage.

70
00:06:18,240 --> 00:06:26,680
So Azure does not use traditional storage area networks or network attached storage solutions as we think about in a data center.

71
00:06:26,960 --> 00:06:31,920
In our data centers, we have these big SANs with lots of fiber connections.

72
00:06:32,360 --> 00:06:34,000
That does not exist in Azure.

73
00:06:34,320 --> 00:06:37,520
Now, I'm not including Azure NetApp files, which we will talk about later on.

74
00:06:37,920 --> 00:06:43,840
That's really the only solution where we actually have NetApp filers sitting aside Azure datacenters.

75
00:06:44,640 --> 00:06:55,920
But for Azure Storage, it's the special storage stamps, so clusters of storage servers that provide the storage services.

76
00:06:55,920 --> 00:06:57,600
They do not use traditional SANs.

77
00:06:58,160 --> 00:07:01,040
It's all focused around software-defined storage.

78
00:07:01,520 --> 00:07:08,640
And these storage services we have powered by Azure Storage are leveraged by pretty much all of the other capabilities of Azure.

79
00:07:08,880 --> 00:07:10,880
You have these hierarchies of things that builds.

80
00:07:10,880 --> 00:07:14,720
You have Azure Storage at the base level on these Azure Storage clusters.

81
00:07:15,520 --> 00:07:19,600
And then databases, the Azure Database Services will use that Azure Storage.

82
00:07:20,000 --> 00:07:24,160
Even more advanced service, that Azure Key Vault, well, it's using Blob under the covers.

83
00:07:24,400 --> 00:07:27,120
So these things all build on top of each other.

84
00:07:28,000 --> 00:07:37,520
And so if Azure is using its own storage architecture of these storage clusters, what it's actually using is this three-tier architecture.

85
00:07:38,640 --> 00:07:43,560
And this provides all of the scale, the capabilities, the replication that we need.

86
00:07:43,560 --> 00:07:49,920
And it's actually built on the work they did for Bing, so Cosmos for part of the replication.

87
00:07:50,560 --> 00:07:51,800
So we have these storage stamps.

88
00:07:51,800 --> 00:07:55,840
So a storage stamp is N number of racks within the cluster.

89
00:07:56,720 --> 00:08:03,680
and you have these different fork domains, you have redundant networking and power, you will get special types of storage stamps.

90
00:08:04,080 --> 00:08:08,960
For example, the premium offerings, they're on a different type of storage stamp that has a different type of disks.

91
00:08:09,600 --> 00:08:14,320
But at the bottom of our hierarchy is the stream layer.

92
00:08:14,680 --> 00:08:17,440
And you can think of the stream layer as the actual bits on the disk.

93
00:08:17,680 --> 00:08:26,480
So this is responsible for the distribution and replication of the data across the servers in this particular cluster, this stamp, to make it durable.

94
00:08:27,040 --> 00:08:33,360
And so this stream is just an ordered list of storage chunks that are made-up of various blocks.

95
00:08:34,560 --> 00:08:36,560
And then we have the partition layer.

96
00:08:37,360 --> 00:08:46,480
Now, the partition layer understands the constructs that we interact with, so it understands abstractions like blobs and tables and queues.

97
00:08:46,720 --> 00:08:53,920
It provides a nice scalable namespace, and then, of course, we want to be able to interact with this, so you get the front-end layer.

98
00:08:54,240 --> 00:08:55,760
So, these are really stateless.

99
00:08:56,240 --> 00:08:57,680
that they just take the requests.

100
00:08:57,840 --> 00:09:10,000
So they take in that API request, it looks up the account name, it does the authentication, then it routes it to the partition layer, which would then, hey, go and take care of that durable actual storage.

101
00:09:11,920 --> 00:09:24,480
Now DNS, Domain Name Services, is used for really everything that we see in Azure to some capacity, but it's the namespace for my storage account.

102
00:09:24,800 --> 00:09:25,920
So what you'll see is

103
00:09:26,320 --> 00:09:31,840
You always want to use encryption, so it's going to be HTTPS, so I'm using TLS 1.2 or above.

104
00:09:32,480 --> 00:09:48,920
Your account name, the type of service, so BLOB, file, queue, table, core.windows.net, and then the partition, which the partition is going to vary depending on the type of service, and then the actual object I want to interact with.

105
00:09:50,080 --> 00:09:55,520
So if I jump over for a second, if I go and look at just one of my storage accounts,

106
00:09:56,960 --> 00:10:04,120
And we can see the various endpoints that I have available for this particular storage account.

107
00:10:04,400 --> 00:10:08,320
So under my settings, I can see my endpoints.

108
00:10:08,920 --> 00:10:13,720
If I go and look at my endpoints, I'll see exactly what I just described.

109
00:10:14,240 --> 00:10:20,720
So if I think about BLOB, for example, there's https because I want that TLS encryption.

110
00:10:21,520 --> 00:10:23,280
That's my storage account name.

111
00:10:23,880 --> 00:10:29,280
I'm currently focused on the BLOB service, and that's core.windows.net.

112
00:10:29,680 --> 00:10:34,800
Then if I started going and looking in particular containers, etc., well that would then follow the URL.

113
00:10:35,440 --> 00:10:38,880
Notice I also have a secondary endpoint for BLOB.

114
00:10:39,520 --> 00:10:48,240
If I go and look at file, well then the name of the file has file between my storage account name and core.windows.net.

115
00:10:48,560 --> 00:10:50,080
Q has Q.

116
00:10:51,440 --> 00:10:57,360
And both queue and table also have secondary endpoints, just like BLOB.

117
00:10:57,840 --> 00:11:00,880
Only file does not have that secondary endpoint.

118
00:11:01,920 --> 00:11:07,840
Now, the use of those secondary endpoints will make more sense in a little bit.

119
00:11:09,120 --> 00:11:15,360
But fundamentally, what we have here is data is replicated in two ways.

120
00:11:15,520 --> 00:11:19,520
We always have 3 copies of the data in our home region.

121
00:11:20,560 --> 00:11:26,320
And that replication within our region is done at the stream layout and it's synchronous.

122
00:11:26,720 --> 00:11:29,800
I.e., there's some client is talking to the storage account.

123
00:11:29,800 --> 00:11:31,680
It says, hey, write this data for me.

124
00:11:31,920 --> 00:11:39,760
It doesn't get the acknowledgement back until it's been durably stored in those 3 copies of the data.

125
00:11:40,000 --> 00:11:43,200
And that could be zone redundant if I pick that as the replication.

126
00:11:43,360 --> 00:11:47,280
So they're actually split over the three AZs within the region.

127
00:11:48,200 --> 00:12:10,480
And then if I'm geo-redundant, and we'll dive into some little bit more detail around this, if I'm geo-redundant, well, then there's another 3 copies in the paired region, but that's asynchronous, which means obviously that those 3 copies are down in the background as quick as it can, but in an unplanned disaster scenario, well, maybe some of that data gets lost.

128
00:12:10,880 --> 00:12:14,960
But I still have the three copies in my region, so there's six then in total.

129
00:12:17,360 --> 00:12:20,320
So let's look at those storage account constructs.

130
00:12:21,200 --> 00:12:29,520
And as we saw, the top level namespace is the storage account for all of the various storage services we're now going to see.

131
00:12:31,200 --> 00:12:34,960
It is created in a region, like pretty much every resource in Azure.

132
00:12:34,960 --> 00:12:38,160
It lives in a specific region and a resource group.

133
00:12:38,880 --> 00:12:43,200
If we jump over for a second and just look at this storage account,

134
00:12:46,400 --> 00:12:52,160
we can see, I exist in a certain location and a certain resource group.

135
00:12:52,880 --> 00:13:03,680
If I wanted to actually create a new storage account, we have to give it a name, but I have to pick a resource group and I have to pick a region.

136
00:13:04,160 --> 00:13:10,000
So those are really some of the core things that I have to give as part of this.

137
00:13:12,160 --> 00:13:16,360
Now, there are actually different types of storage account.

138
00:13:18,240 --> 00:13:22,400
The portal kind of hides these a lot from you today.

139
00:13:22,400 --> 00:13:27,000
It just asks you some general questions about, hey, what are you going to use this for?

140
00:13:27,000 --> 00:13:29,760
And then it does ask you for performance.

141
00:13:30,080 --> 00:13:35,040
But if I'm using the CLI, if I'm using templates, I have to specify the exact type.

142
00:13:35,440 --> 00:13:42,560
Now we have things like standard and premium performance, which changes that backend storage stamp used to provide the higher performance.

143
00:13:43,120 --> 00:13:46,080
From a storage account type, we have general purpose V2.

144
00:13:46,560 --> 00:13:49,440
Now that is what we use for most general things.

145
00:13:49,600 --> 00:13:53,760
It supports BLOB and queue and table and files.

146
00:13:54,240 --> 00:13:56,880
So that's typically what you're going to leverage.

147
00:13:57,520 --> 00:14:05,280
But if we pick the premium offerings, then you get into these very specific types of account that only support a particular type of service.

148
00:14:05,600 --> 00:14:10,080
So if I do premium BLOB, then it's going to use BLOB storage.

149
00:14:10,720 --> 00:14:15,840
If I use premium files, it's going to use file storage type of account.

150
00:14:16,000 --> 00:14:21,520
Or if I actually use provisioned V2, if I pick page for premium, well, then it's page.

151
00:14:22,080 --> 00:14:26,840
So depending on what I pick, it's going to drive that particular type of storage account.

152
00:14:27,840 --> 00:14:30,480
So here we can see we have these options.

153
00:14:30,880 --> 00:14:33,040
Notice it's asking me a question.

154
00:14:33,840 --> 00:14:37,920
Hey, what is the primary service you want to use with this?

155
00:14:38,560 --> 00:14:42,640
So I say, hey, I'm going to use BLOB or files or tables and queues.

156
00:14:43,840 --> 00:14:52,240
Now if I just pick BLOB, notice it's saying the performance is still standard, which means it's going to use that general purpose V2.

157
00:14:52,960 --> 00:14:56,080
But if I flip this and was to pick premium,

158
00:14:56,880 --> 00:15:01,120
now it's going to be a particular type of account.

159
00:15:01,440 --> 00:15:08,480
And here I can pick for that premium, hey, is it block blobs, file shares, or page blobs?

160
00:15:09,680 --> 00:15:21,040
Additionally, if I pick West US 2 and I pick files and standard, you'll actually notice it's giving me this other option of how I'm going to get billed and how I can handle the performance.

161
00:15:21,600 --> 00:15:28,400
So if I pick provision V2, then it will again create a file storage account, a V2 provisioned.

162
00:15:28,640 --> 00:15:31,280
So there are some specifics that go on behind the scenes.

163
00:15:31,280 --> 00:15:43,840
The portal abstracts a lot of it for you, but if I'm actually using templates or CLI or REST API, I would actually have to understand those various options available for me.

164
00:15:44,400 --> 00:15:46,320
But just kind of know that is there.

165
00:15:48,560 --> 00:15:49,280
And then

166
00:15:50,000 --> 00:15:52,960
So I picked the SKU, I picked the performance.

167
00:15:54,080 --> 00:15:56,400
Then we have different types of resiliency.

168
00:15:56,480 --> 00:16:10,000
Now these are going to offer different SLAs, SLAs in terms of its availability to interact with the service, SLA in terms of the ability to read from it, SLA to write to it, and then completely separately there's things about the durability.

169
00:16:10,000 --> 00:16:14,640
Now remember, let's remember those different partitions, the different layers.

170
00:16:15,600 --> 00:16:20,240
Imagine that front end layer was having a problem, so I can't interact with my data.

171
00:16:20,640 --> 00:16:22,400
That doesn't mean I'm losing data.

172
00:16:22,400 --> 00:16:24,800
The data is still highly durable on the disk.

173
00:16:25,200 --> 00:16:31,680
So if we go and look at the durability for a second, this is the chance of actually losing data.

174
00:16:31,680 --> 00:16:37,400
So even LRS, just those regular 3 copies, they have 11 nines of durability.

175
00:16:37,400 --> 00:16:40,320
I don't think there's ever actually been data loss in Azure.

176
00:16:40,960 --> 00:16:45,040
If we pick the zone redundant, well now it's 12 nines.

177
00:16:46,560 --> 00:16:48,960
the durability, the chance of losing any data.

178
00:16:49,840 --> 00:16:53,040
And I think if you, I'm sure it shows it somewhere, there.

179
00:16:53,200 --> 00:16:57,440
GRS, 16 nines of durability.

180
00:16:57,440 --> 00:17:04,920
So you basically get these silly, silly levels of durability, but then that doesn't mean I can always interact with it.

181
00:17:04,920 --> 00:17:08,000
My data is safe, but can I actually interact?

182
00:17:08,840 --> 00:17:14,720
And that's where you, the ability to maybe have those additional copies replicated in different places,

183
00:17:15,120 --> 00:17:18,280
to maybe be able to always interact with my data.

184
00:17:19,200 --> 00:17:20,480
Well, that can vary.

185
00:17:20,720 --> 00:17:24,000
There's LRS, GRS, ZRS, GCRS.

186
00:17:24,320 --> 00:17:26,280
There's alternate options.

187
00:17:26,280 --> 00:17:42,240
If I picked, for example, GRS, I then had this option to give me read access to that secondary copy of it, even if I don't have kind of some regional problem going on at that moment in time.

188
00:17:42,560 --> 00:17:44,800
So I have all these different resiliency options.

189
00:17:45,200 --> 00:17:50,960
Now again, the key point to remember here is these are about the ability to interact with the data.

190
00:17:51,440 --> 00:18:06,960
This is not risking the durability of the data, but as you saw, the durability does increase, which makes sense if I think about, hey, the more I spread out my data or have more copies in like 2 regions, I get an even better assurance that my data would be available.

191
00:18:08,320 --> 00:18:09,720
So let's dive into

192
00:18:11,040 --> 00:18:15,040
those different options we have and really what that means for the storage of my data.

193
00:18:15,760 --> 00:18:20,400
Now I'm going to focus initially within a particular region.

194
00:18:23,200 --> 00:18:24,280
So this is region one.

195
00:18:24,280 --> 00:18:31,840
And when we talked about those storage stamps, those storage clusters, let's initially just focus on one of them.

196
00:18:32,400 --> 00:18:36,400
So I've got a particular storage cluster.

197
00:18:37,360 --> 00:18:46,560
Now, if I pick the locally redundant storage option, remember with locally redundant, there's always 3 copies of whatever data you have.

198
00:18:47,680 --> 00:18:49,440
So that is LRS.

199
00:18:49,840 --> 00:18:52,880
But those 3 copies are in the same storage cluster.

200
00:18:54,400 --> 00:18:56,080
The next option is ZRS.

201
00:18:56,320 --> 00:19:03,840
So now remember, we have the option of the three availability zones we have in any one place.

202
00:19:06,000 --> 00:19:11,280
So now let's say I've got AZ 1, AZ 2 and AZ 3.

203
00:19:12,000 --> 00:19:26,480
So with ZRS, now what it's doing is it's still just three copies, but those 3 copies are now being distributed over storage clusters in the three availability zones.

204
00:19:26,880 --> 00:19:31,520
So I've got an even higher resiliency of my data

205
00:19:32,320 --> 00:19:39,680
Remember the drawability went up a little bit, but also those different storage clusters, where they have those different front-end services.

206
00:19:39,840 --> 00:19:47,360
So my ability to interact should be increased as well, because now I'm resilient if just one of them had some failure going on.

207
00:19:48,640 --> 00:19:51,920
But now remember, we do have those pairs of regions.

208
00:19:52,080 --> 00:19:58,160
So now imagine, I'm just going to do a little bit less drawing, I have region 2.

209
00:19:58,840 --> 00:20:02,400
And in this specific case, this is the paired region.

210
00:20:03,040 --> 00:20:08,240
This is where Microsoft picks those pairings, they have designed them, so there's a big distance between them.

211
00:20:09,040 --> 00:20:11,040
And this is used by storage accounts.

212
00:20:11,200 --> 00:20:13,760
So now we have the option of GRS.

213
00:20:14,240 --> 00:20:24,000
So if I do GRS, well with GRS, I have the three copies within a certain storage cluster.

214
00:20:25,760 --> 00:20:28,160
And then what it, so remember that these are all synchronous.

215
00:20:29,000 --> 00:20:48,360
And now what it's going to do to a certain storage cluster on this side, it's going to asynchronously replicate, and there'll be 3 copies within a specific storage cluster on the other side.

216
00:20:48,360 --> 00:20:56,480
And then finally, there's kind of a hybrid of all of these things, and I can do

217
00:20:57,680 --> 00:21:03,000
GZRS, where it's a combination of ZRS and GRS.

218
00:21:03,120 --> 00:21:08,960
So on the primary region, the three copies are distributed over the three AZs.

219
00:21:09,920 --> 00:21:17,920
But on the paired region, the three copies are still within a single storage cluster.

220
00:21:18,000 --> 00:21:19,840
It is not ZRS on the other side as well.

221
00:21:19,840 --> 00:21:21,680
Just important to understand that.

222
00:21:23,040 --> 00:21:25,840
And then for both of these, for the services,

223
00:21:26,160 --> 00:21:28,240
You have this optional choice.

224
00:21:28,320 --> 00:21:37,760
There's a little bit of a, I pay a little bit more money, but then I could say, and actually what I want over here is the read access to it.

225
00:21:38,400 --> 00:21:41,240
And that's where, remember I showed you that second endpoint?

226
00:21:42,240 --> 00:21:49,120
I can use the secondary endpoint to talk to the services in this region to maybe go and read from those services.

227
00:21:49,440 --> 00:21:50,960
Now that doesn't work for Azure files.

228
00:21:51,320 --> 00:21:53,280
but it works for BLOB, queue, and table.

229
00:21:53,520 --> 00:21:56,160
So I have those different capabilities available to me.

230
00:21:56,320 --> 00:22:02,400
Now, in a real failover, that primary endpoint will just now point to this one.

231
00:22:03,400 --> 00:22:06,080
Realistically, I don't think Azure has ever had that happen.

232
00:22:06,080 --> 00:22:08,000
They've never done a full regional failover.

233
00:22:09,600 --> 00:22:15,840
So there were actually some changes coming around that, and I'll show you this in a second.

234
00:22:17,520 --> 00:22:21,920
But yes, you're not going to have that secondary endpoint for files because it does not support that.

235
00:22:22,640 --> 00:22:33,600
Now you can switch between like LRS and GRS and there's some special steps for the ZRS stuff, but you can absolutely manage and change that resiliency.

236
00:22:33,600 --> 00:22:36,480
You're not locked in because that's what I picked when I created the storage account.

237
00:22:37,680 --> 00:22:41,840
From a cost perspective, obviously as I move down these, they cost more money.

238
00:22:42,400 --> 00:22:45,840
ZRS costs more than LRS, GRS costs more than those because there's

239
00:22:46,400 --> 00:22:47,840
6 copies instead of three.

240
00:22:48,240 --> 00:22:53,040
GZRS costs more than GRS because those three are spread over the AZs and that.

241
00:22:53,680 --> 00:22:57,680
I also pay for the data egress because it's coming out of the region.

242
00:22:57,680 --> 00:23:02,160
So there's some data transfer charges involved in that scenario as well.

243
00:23:03,360 --> 00:23:07,120
Now I mentioned that Azure has never had a full regional outage.

244
00:23:07,120 --> 00:23:10,160
So they have never actually done this failover thing.

245
00:23:10,800 --> 00:23:14,640
But imagine there's some maybe smaller scale issue that's impacting you.

246
00:23:15,520 --> 00:23:21,120
So what they do give you the ability to do now is customer managed failover.

247
00:23:21,680 --> 00:23:28,400
So if I go and look at storage account, now firstly I can see my redundancy.

248
00:23:29,040 --> 00:23:31,200
So I see data managed redundancy.

249
00:23:31,920 --> 00:23:32,880
I can select that.

250
00:23:34,320 --> 00:23:35,480
And it will show me what I have.

251
00:23:35,480 --> 00:23:36,640
So this is GRS.

252
00:23:36,720 --> 00:23:38,160
So I can see, look, it's geo-redundant.

253
00:23:38,520 --> 00:23:41,280
And notice it's giving me some options here to change between them.

254
00:23:41,320 --> 00:23:44,960
ZRS, as I mentioned, there are some special things to be able to switch to ZRS.

255
00:23:46,000 --> 00:23:48,000
But it shows me my primary and my secondary.

256
00:23:48,120 --> 00:23:51,040
It shows me a nice little picture of where they are.

257
00:23:52,240 --> 00:23:57,680
Now, one of the things I can do here is I have this prepare for failover.

258
00:23:58,720 --> 00:24:02,480
If I select this, I can do an unplanned failover.

259
00:24:02,960 --> 00:24:08,080
Now, what this is doing is it's showing me when is the last time these were synchronized.

260
00:24:08,640 --> 00:24:14,240
If there was data after this time, well, then I would have the potential

261
00:24:14,640 --> 00:24:16,240
to lose that data.

262
00:24:17,760 --> 00:24:21,200
And you'll notice there's this planned option, which is grayed out for me.

263
00:24:21,200 --> 00:24:22,320
That is in preview.

264
00:24:23,040 --> 00:24:36,320
So the difference here is when I perform an unplanned failover, what this will actually do is the secondary would become the primary, but it would become LRS.

265
00:24:37,280 --> 00:24:39,360
It doesn't reverse those things.

266
00:24:39,680 --> 00:24:42,400
So I would then need to actually go

267
00:24:43,280 --> 00:24:47,040
and then turn on GRS to reverse it back the other way.

268
00:24:48,080 --> 00:24:55,680
Planned, that preview functionality is only available in certain regions, not the ones I'm using, but it would actually swap the primary and secondary.

269
00:24:56,000 --> 00:24:58,960
So it would keep it as GRS and it would reverse the flow of application.

270
00:24:58,960 --> 00:25:01,840
So that would obviously be a really nice capability to do.

271
00:25:02,160 --> 00:25:07,480
But just realize you have the ability to actually do that custom managed failover.

272
00:25:07,480 --> 00:25:08,640
So Azure is not

273
00:25:09,280 --> 00:25:16,000
raising a regional outage, then maybe they're saying there's impacting my service, I can choose to do that customer managed failover.

274
00:25:19,040 --> 00:25:24,720
There are APIs available to actually go and interact with the services.

275
00:25:24,720 --> 00:25:28,400
So that's the ability and those SLAs to actually be able to talk to the various data.

276
00:25:29,200 --> 00:25:35,720
And there are different options depending on, well, what is the actual service I'm using.

277
00:25:36,160 --> 00:25:41,760
There's always kind of these base APIs, and there's ones for BLOB and queues and tables.

278
00:25:42,000 --> 00:25:44,320
But then additionally, imagine files.

279
00:25:44,480 --> 00:25:46,720
Well, files, I can talk to it via SMB.

280
00:25:46,720 --> 00:25:48,400
It's a file-based protocol.

281
00:25:48,960 --> 00:25:50,400
I can also use NFS.

282
00:25:50,600 --> 00:25:52,000
I can use NFS for BLOB as well.

283
00:25:52,160 --> 00:25:54,080
I can use SFTP for BLOB.

284
00:25:54,720 --> 00:25:56,280
I can use HDFS for data lake.

285
00:25:56,280 --> 00:26:02,400
I'm going to talk some more about these, but they will vary depending on the actual service I want to talk to.

286
00:26:04,000 --> 00:26:04,240
Now,

287
00:26:05,440 --> 00:26:10,800
The capacity, the IOPS, the throughput vary based on a lot of different things.

288
00:26:12,720 --> 00:26:20,800
What SKU I picked, what performance I picked, maybe specifically did I use the PAYGO or the provisioned options?

289
00:26:21,080 --> 00:26:30,400
And we'll go into some more detail about that, but realize there are some differences in what I get out of the performance depending on those options I choose.

290
00:26:30,440 --> 00:26:32,560
And obviously when it's like standard versus

291
00:26:34,040 --> 00:26:41,840
premium and performance options, obviously that impacts the performance I'm going to get for that service, but I always pay differently.

292
00:26:42,320 --> 00:26:45,200
So whenever you think, oh, it's higher performance, you're going to pay more money for that.

293
00:26:46,440 --> 00:26:59,120
When I think about some of the provisioned options, though, maybe I've got a better consistency in what my bill will be, and that might mean more to me as a customer than paying the minimum, but hey, I get these varied bills.

294
00:26:59,120 --> 00:27:01,440
I'd rather have consistency in my billing.

295
00:27:03,040 --> 00:27:03,840
Additionally,

296
00:27:04,240 --> 00:27:10,560
Some different services have tiers available for them, both BLOB and files.

297
00:27:10,960 --> 00:27:15,360
So with BLOB, I'll see there's a hot, a call, a cold, an archive.

298
00:27:15,520 --> 00:27:19,280
With files, I'll see a transaction optimized, I'll see a hot and a call.

299
00:27:20,000 --> 00:27:25,360
And this lets you balance the need to store and have the data available.

300
00:27:26,320 --> 00:27:29,680
with how much you intend to actually interact with the data.

301
00:27:30,080 --> 00:27:38,080
Typically, over time, you'll have older data that you still need maybe instantly available, but I know I'm going to interact with it less.

302
00:27:38,720 --> 00:27:49,120
So what these tiers let me do is shift to say, look, I'll pay less for the storage of the data, but I'll pay more when I actually need to go and interact with the data.

303
00:27:49,280 --> 00:27:55,760
So if a really new data that I intend to interact with a lot, maybe hot is the right option or call is the right option.

304
00:27:56,200 --> 00:28:03,600
But when I just have data that is just there, but I need instant access, well, maybe cold is the better option because I know I'm going to do less operations against it.

305
00:28:03,600 --> 00:28:07,280
So it's about you being able to optimize your build for this.

306
00:28:08,880 --> 00:28:10,960
And I can enable monitoring and logging.

307
00:28:11,120 --> 00:28:14,400
There's different metrics available for the different services.

308
00:28:14,640 --> 00:28:25,360
I can use diagnostic settings to control, hey, I want to send these logs to these different services, be it storage account or an event hub or a log analytics workspace.

309
00:28:26,160 --> 00:28:28,520
to give me insight into actually what I'm doing.

310
00:28:28,520 --> 00:28:30,480
And the granularity can vary.

311
00:28:30,880 --> 00:28:32,640
If we jump over for a second.

312
00:28:34,880 --> 00:28:42,640
So here, if we scroll down, we can see we have logs and we have metrics.

313
00:28:43,040 --> 00:28:47,600
So if I select metrics, for example, there'll be metrics for the account level.

314
00:28:48,160 --> 00:28:50,480
Then there's metrics for the particular services.

315
00:28:51,120 --> 00:28:53,760
If I'm on a particular service, for example,

316
00:28:56,160 --> 00:29:04,400
Then maybe I'll pick BLOB, and then for BLOB, or there's BLOB capacity, container account, the types of transaction you're performing against it.

317
00:29:04,400 --> 00:29:06,080
This is what I pay money for.

318
00:29:06,560 --> 00:29:10,320
Depending on what I pick, I can aggregate it over different things as well.

319
00:29:10,320 --> 00:29:11,920
So let's say my availability.

320
00:29:11,920 --> 00:29:14,800
I can do average, minimum, maximum.

321
00:29:15,280 --> 00:29:19,120
So I have choices on exactly what I want to do.

322
00:29:19,120 --> 00:29:23,280
So those metrics are going to vary greatly depending on the specific service.

323
00:29:24,320 --> 00:29:34,920
So just realize you have really good ability to get insight into what's happening on your storage account, which obviously you're going to care about because you're going to pay for those capabilities.

324
00:29:34,920 --> 00:29:45,840
I want to talk on object-level replication, because obviously those paired storage accounts we talked about, maybe I don't want to use the paired regions.

325
00:29:46,320 --> 00:29:49,960
Maybe I want some more flexibility in actually what I replicate.

326
00:29:50,480 --> 00:29:54,240
So object level replication lets us do that for blobs.

327
00:29:55,240 --> 00:29:59,840
Now what it's doing is for block blobs or containers, what blobs live in,

328
00:30:00,880 --> 00:30:06,960
It enables us to be replicated to a container within another storage account of our choice.

329
00:30:07,600 --> 00:30:16,200
Now, it's using a couple of features we'll talk about later on called change feed and BLOB versioning, which really just lets us track the different versions if a BLOB is being changed.

330
00:30:16,200 --> 00:30:19,760
And then the change feed is when did those changes take effect.

331
00:30:19,760 --> 00:30:23,840
So it's a way to be alerted to say, oh, look, the BLOB has updated.

332
00:30:23,840 --> 00:30:25,120
The BLOB has been changed.

333
00:30:25,360 --> 00:30:27,120
So I can say, oh, the BLOB has been changed.

334
00:30:27,480 --> 00:30:28,400
What's changed?

335
00:30:28,720 --> 00:30:30,640
I need to go and send that block somewhere else.

336
00:30:30,640 --> 00:30:32,880
So this is only for block blobs.

337
00:30:32,960 --> 00:30:34,840
This is not for append.

338
00:30:34,840 --> 00:30:35,960
This is not for page.

339
00:30:35,960 --> 00:30:43,720
And really the way this is going to work, it's going to give you all of the flexibility into how this gets replicated.

340
00:30:43,720 --> 00:30:47,560
So remember, this was this hard link in between region one and region 2.

341
00:30:47,560 --> 00:30:48,960
They were paired regions.

342
00:30:49,520 --> 00:30:53,440
So now what we're going to think about is, well, I just have a storage account.

343
00:30:53,920 --> 00:30:56,320
So I've got my storage account one.

344
00:30:57,040 --> 00:31:00,240
And in that storage account, we're focusing on the BLOB service right now.

345
00:31:01,440 --> 00:31:07,680
But I'm going to create 2 containers, which is what I then put the BLOBs into.

346
00:31:07,920 --> 00:31:14,640
So I've got container one with some stuff in it, and I've got a container 2 with some other stuff in it.

347
00:31:15,520 --> 00:31:21,600
And then, well, in one region, a different region, not the paired region, it could be if I wanted to, but it doesn't have to be.

348
00:31:21,600 --> 00:31:24,160
I've got another completely different storage account.

349
00:31:24,720 --> 00:31:46,960
So, whereas this is basically the same storage account when I'm using the paired region, this is a completely different storage account, completely different endpoint, its own thing, and I create another storage account, and in that I create another container, container three, maybe in another region I create another storage account, storage account three, and I create another container over there.

350
00:31:48,400 --> 00:32:00,040
And what object-level replication lets me do is, I can say, Well, actually, from this container, I want you to replicate to this container in this storage account over here.

351
00:32:00,040 --> 00:32:07,280
For this container, I want you to replicate to a completely different storage account and to this container over here.

352
00:32:08,080 --> 00:32:08,480
Now, it's...

353
00:32:08,920 --> 00:32:11,360
It's going to be asynchronous for application again.

354
00:32:11,760 --> 00:32:12,800
This is not synchronous.

355
00:32:12,800 --> 00:32:16,000
It's not guaranteeing, hey, I do a commit over here.

356
00:32:16,240 --> 00:32:21,360
It won't acknowledge that commit to the application performing that until it's copied here.

357
00:32:21,440 --> 00:32:22,320
It's asynchronous.

358
00:32:22,480 --> 00:32:24,240
There's a distance between these things.

359
00:32:24,640 --> 00:32:25,800
I don't want synchronous.

360
00:32:25,800 --> 00:32:27,200
It would cripple the performance.

361
00:32:28,320 --> 00:32:34,720
But remember, it's using that change feed to know when something happens and it can use the BLOB versioning to work out what has changed and have the version it needs.

362
00:32:34,960 --> 00:32:36,320
So we can copy that thing over.

363
00:32:37,960 --> 00:32:43,920
What's nice about this though is because it's this object level replication, I can do things like filtering.

364
00:32:44,800 --> 00:32:48,480
So I could apply a filter as to what I actually want to copy.

365
00:32:49,360 --> 00:32:59,600
Another thing I can do here is it's going to work for premium block blobs as well, whereas traditionally there's limitations to what I can do with premium.

366
00:32:59,760 --> 00:33:06,960
So it's not just general purpose V2, it's premium block BLOB accounts, but not if I have data lake turned on.

367
00:33:07,320 --> 00:33:14,640
So there's different features and we're going to talk more about the data lake, but this object level replication is not for hierarchical namespace.

368
00:33:17,360 --> 00:33:18,840
It doesn't align to the regional pairs.

369
00:33:18,840 --> 00:33:21,120
As we talked about, it can be any region you want.

370
00:33:22,480 --> 00:33:25,520
I have flexibility in which blobs are replicated.

371
00:33:25,840 --> 00:33:36,160
So I can specify a pre-fix that must be matched for the blobs if I don't want to send all of them or only want certain things to actually go over there.

372
00:33:37,040 --> 00:33:42,880
I can have a certain number of rules within a policy, but I can only replicate to one place.

373
00:33:42,880 --> 00:33:44,480
That's kind of a key point over here.

374
00:33:44,480 --> 00:33:48,920
One of the nice things is I can use different tiers for the source and the target.

375
00:33:49,200 --> 00:33:55,760
So I could be hot maybe on the source side, but maybe call on the target side.

376
00:33:56,640 --> 00:34:00,000
So that gives me a lot more flexibility within those things.

377
00:34:00,640 --> 00:34:01,680
If we jump over,

378
00:34:03,600 --> 00:34:14,240
So if I maybe just look for a second at object replication, I could go and create a replication rule.

379
00:34:15,440 --> 00:34:19,600
I would pick the destination storage account, I'll do one in the same.

380
00:34:20,080 --> 00:34:25,760
So I would pick the source container on my side, the destination container in the other storage account.

381
00:34:27,760 --> 00:34:30,640
I could add filters, so I could add a prefix match.

382
00:34:31,440 --> 00:34:33,840
I can then control, which objects?

383
00:34:33,920 --> 00:34:35,440
Is it only the new stuff?

384
00:34:36,160 --> 00:34:37,360
Is it everything?

385
00:34:37,760 --> 00:34:41,840
Is it some custom, so only things that were created starting from a certain date?

386
00:34:42,320 --> 00:34:48,560
So we get a nice selection of options for this, but it gives me now flexibility.

387
00:34:48,560 --> 00:34:55,040
I don't have to go and align to those storage account pairings, which we normally have to do.

388
00:34:55,760 --> 00:34:58,560
But remember, it is using the change feed.

389
00:34:59,040 --> 00:35:03,440
it is now going to require transactions to be used.

390
00:35:03,440 --> 00:35:07,280
So it's going to be reading, it's going to be writing, and I'll have to pay for that.

391
00:35:07,520 --> 00:35:08,960
I'll have to pay for the network egress.

392
00:35:08,960 --> 00:35:13,360
So don't forget to work out all of the costs associated with this.

393
00:35:15,200 --> 00:35:19,040
So let's look at what are the actual storage account services available.

394
00:35:19,040 --> 00:35:22,560
Now, when it's general purpose V2, they are all available.

395
00:35:23,200 --> 00:35:26,080
Remember, if I pick one of those more specific ones like

396
00:35:27,200 --> 00:35:31,760
block BLOB or page or file, so it's only going to support that one particular service.

397
00:35:34,240 --> 00:35:34,800
So BLOB.

398
00:35:36,080 --> 00:35:43,680
BLOB is our probably fundamental type of object that nearly everything uses in Azure.

399
00:35:44,160 --> 00:35:48,600
It's really useful for very large amounts of unstructured data.

400
00:35:49,280 --> 00:35:51,040
Now there are different types of this.

401
00:35:51,600 --> 00:35:56,160
So the big thing we really think about when I think of BLOB is BLOB BLOB.

402
00:35:57,040 --> 00:36:06,960
So with Block BLOB, this is different size blocks that are basically formed together to create what is this Block BLOB.

403
00:36:07,280 --> 00:36:09,600
And it's useful for storing anything.

404
00:36:10,160 --> 00:36:14,160
Now by default, Block BLOB is a flat namespace.

405
00:36:14,400 --> 00:36:17,680
What I mean by that is there is no concept of directories.

406
00:36:17,680 --> 00:36:19,600
Now you're going to say, that's not true.

407
00:36:19,760 --> 00:36:22,160
I've seen directories when I've played with Block BLOB.

408
00:36:22,560 --> 00:36:24,000
You've seen virtual directories.

409
00:36:24,560 --> 00:36:32,000
The way that works is it basically adds in the directory name as part of the name of the block BLOB, but it doesn't actually understand them.

410
00:36:32,400 --> 00:36:39,040
Whereas when I turn on the hierarchical namespace, HNS, this is what the Azure Data Lake Storage Gen.

411
00:36:39,040 --> 00:36:39,440
2 is.

412
00:36:39,440 --> 00:36:45,520
It sits on top of BLOB, but now it adds a true hierarchy to that.

413
00:36:47,040 --> 00:36:50,800
And then when I turn on the hierarchical namespace,

414
00:36:52,480 --> 00:36:55,520
then I can get other capabilities available to me.

415
00:36:56,240 --> 00:36:58,920
For example, one of the things we have is then called NFS.

416
00:36:58,920 --> 00:37:01,120
So NFS is a different type of protocol.

417
00:37:01,680 --> 00:37:09,760
So NFS 3 lets us then actually go and get capabilities around ways I can interact with the block BLOB.

418
00:37:10,480 --> 00:37:17,040
Now I can only use it from a certain network that's connected to it, and I have to have again that hierarchical namespace enabled.

419
00:37:17,680 --> 00:37:26,960
I can get SSH FTP, so it's going to get me encrypted FTP services to, again, when I have that data lake enabled for me.

420
00:37:27,120 --> 00:37:28,880
So there's some really nice capabilities.

421
00:37:28,880 --> 00:37:32,520
So if we think for a second about the services, where can I draw?

422
00:37:33,920 --> 00:37:36,240
So we start from here.

423
00:37:36,240 --> 00:37:37,760
So imagine this is a storage account.

424
00:37:38,400 --> 00:37:42,960
So there are many types of service available to that storage account.

425
00:37:45,320 --> 00:37:45,680
BLOB.

426
00:37:48,480 --> 00:37:53,360
So when I'm dealing with BLOB, we have containers.

427
00:37:53,360 --> 00:38:00,720
So containers is the structure into which we then put our blobs into.

428
00:38:01,600 --> 00:38:08,240
Now, if I enable the hierarchical namespace, then we actually have true, these become folders.

429
00:38:09,040 --> 00:38:12,880
And what we're going to store in here initially is a block BLOB.

430
00:38:13,920 --> 00:38:14,480
That's the

431
00:38:15,200 --> 00:38:18,480
most fundamental type, and again, that is a flat namespace.

432
00:38:18,480 --> 00:38:21,520
There are no true directories within that.

433
00:38:22,160 --> 00:38:28,640
But if at time of creation, I pick to turn on the hierarchical namespace, then it becomes a data lake.

434
00:38:28,960 --> 00:38:30,640
This is what the ADLS Gen.

435
00:38:30,640 --> 00:38:35,280
2, my hierarchical namespace, is leveraging.

436
00:38:35,840 --> 00:38:42,320
And when I have the hierarchical namespace, well, then we get features like NFS 3.0,

437
00:38:43,200 --> 00:38:45,520
and we get features like the SFTP.

438
00:38:46,800 --> 00:38:50,800
And I have to have turned on the hierarchical namespace to then get those capabilities.

439
00:38:52,080 --> 00:38:56,720
Now, there's different capabilities I get depending on those things.

440
00:38:57,200 --> 00:38:59,600
but it's basically adding additional APIs.

441
00:38:59,840 --> 00:39:08,240
So hey, I can use the BLOB REST API, I can use here the Data Lake API, and I can use the NFS ways of talking into it, I can use the SFTP ways of talking to it.

442
00:39:08,560 --> 00:39:13,520
So I just get more and more flexibility in ways I can interact with the service.

443
00:39:14,560 --> 00:39:25,680
And once again, if we go and look, if I was creating a storage account for a second, one of the things we'll kind of see if I just leave it as just BLOB,

444
00:39:28,080 --> 00:39:33,040
You get these advanced options, but this is kind of the big one that makes it a data lake.

445
00:39:33,680 --> 00:39:40,640
If I enable the hierarchical namespace, then it fundamentally becomes the date lake storage Gen.

446
00:39:40,640 --> 00:39:40,960
2.

447
00:39:42,080 --> 00:39:53,120
So all those different additional capabilities, and then if I turn on the hierarchical namespace, well then you can do things like enable SFTP, I can enable

448
00:39:53,880 --> 00:39:58,800
NFS v3 and it's telling you how you need the hierarchical namespace turned on.

449
00:39:59,200 --> 00:40:02,160
Those things you can't change once you create the storage account.

450
00:40:02,240 --> 00:40:08,960
So I either turn on hierarchical namespace or I don't, I can't go and turn it on later on.

451
00:40:09,920 --> 00:40:13,840
It's fundamentally changing how we're doing things within the storage account.

452
00:40:14,320 --> 00:40:22,880
But if I go and look at my storage browser for a second and look at BLOB, it's showing me all of those containers within it.

453
00:40:23,680 --> 00:40:27,840
So I have a container, and notice here it looks like I've got a folder called testing.

454
00:40:29,320 --> 00:40:40,400
And I can go into that folder, but it's really just as part of the name of this file, it is actually putting in the name of the folder as part of that file name.

455
00:40:40,720 --> 00:40:45,440
There is no actual true folder system.

456
00:40:45,840 --> 00:40:50,560
It's just the GUI is doing a nice job for me in putting that in.

457
00:40:50,840 --> 00:40:52,560
but that isn't actually a true folder.

458
00:40:52,560 --> 00:40:56,080
It's just part of the name if I was actually go and look at the BLOB directly.

459
00:40:56,160 --> 00:40:59,360
So hierarchical namespace has true folders.

460
00:41:00,000 --> 00:41:01,200
Flat namespace does not.

461
00:41:01,200 --> 00:41:01,920
They're all virtual.

462
00:41:01,920 --> 00:41:03,840
It's kind of creating it ad hoc.

463
00:41:05,280 --> 00:41:05,680
Okay.

464
00:41:08,240 --> 00:41:09,120
Then we have page.

465
00:41:09,680 --> 00:41:12,320
Page is made-up of pages, 512 bytes.

466
00:41:12,720 --> 00:41:15,680
It's really optimized for read-write disks.

467
00:41:15,920 --> 00:41:17,200
Now in the old days,

468
00:41:17,760 --> 00:41:20,400
The early Azure, we would interact with page blobs.

469
00:41:20,480 --> 00:41:21,440
Now we don't.

470
00:41:21,440 --> 00:41:27,520
We have something called managed disks, which we're going to talk about, which means that I don't typically in most scenarios use these anymore.

471
00:41:28,240 --> 00:41:29,200
Then you have append.

472
00:41:29,600 --> 00:41:33,680
It's a block BLOB, but I only add pages to the end of it.

473
00:41:34,160 --> 00:41:36,480
I cannot update or delete existing blocks in it.

474
00:41:36,560 --> 00:41:38,800
It's really useful to imagine a log scenario.

475
00:41:39,360 --> 00:41:44,560
So it makes it really easy to just go and keep adding things to the end of this file.

476
00:41:45,200 --> 00:41:46,400
So we have block BLOB.

477
00:41:47,920 --> 00:42:01,800
And then we also have the options that I can do page, use for that really random type of interaction, and I can do append, really useful for the log type scenarios here.

478
00:42:03,120 --> 00:42:07,840
Now you get other capabilities as part of these services.

479
00:42:08,040 --> 00:42:10,000
For example, there's a thing called BLOB index tags.

480
00:42:10,560 --> 00:42:15,280
BLOB index tags are key value pairs like the tags we have in Azure,

481
00:42:15,640 --> 00:42:18,480
but that's part of the Azure Resource Manager control plane.

482
00:42:19,200 --> 00:42:23,600
But these are actually part of the data interactions we have.

483
00:42:24,080 --> 00:42:31,200
And I can then use those to maybe go and find data, but I can also use it as part of the attribute-based access control we saw earlier on.

484
00:42:32,080 --> 00:42:37,200
So I can have things like a process day, a project, a classified, whatever makes sense.

485
00:42:37,520 --> 00:42:39,680
I can have up to 10, let's go and look at these.

486
00:42:40,240 --> 00:42:43,840
I can have up to 10 of these index tags.

487
00:42:44,240 --> 00:42:48,000
So if I jump back over to here, I'm just looking at images again.

488
00:42:48,960 --> 00:42:50,080
Let's go up a folder.

489
00:42:51,040 --> 00:42:59,920
If I was to just look at this particular file, we can see, well, I've got this tag here.

490
00:43:00,160 --> 00:43:02,400
Milestone related is set to true.

491
00:43:03,280 --> 00:43:07,280
So it's just some piece of data that I can use.

492
00:43:07,560 --> 00:43:11,440
And I'm using this storage browser capability.

493
00:43:12,800 --> 00:43:17,280
There's also the ability to just go and scroll down under data storage and look at containers.

494
00:43:18,560 --> 00:43:21,520
And I get a similar kind of pretty nice view here.

495
00:43:21,680 --> 00:43:22,960
Then I could add a filter.

496
00:43:23,360 --> 00:43:24,560
So I could add a filter here.

497
00:43:24,560 --> 00:43:30,880
So I could type in milestone related and say only show me where it's true.

498
00:43:32,640 --> 00:43:34,560
And now as the name suggests, I'm filtering.

499
00:43:34,560 --> 00:43:36,720
So now it only shows me the two images.

500
00:43:37,360 --> 00:43:41,600
where that BLOB index tag matched the value I specified.

501
00:43:41,600 --> 00:43:52,320
So it's a really good way of adding that metadata, both for maybe tracking data about the object, but maybe stuff I actually want to go and search on it as well.

502
00:43:53,200 --> 00:43:58,720
So it's a really cool capability to have that with the BLOB index tags.

503
00:43:59,520 --> 00:44:01,280
There's things like BLOB inventory.

504
00:44:01,360 --> 00:44:06,320
So BLOB inventory will go and create reports on a daily or weekly basis.

505
00:44:06,480 --> 00:44:13,360
So if I come out of this for a second and go to my data management, there's a BLOB inventory feature.

506
00:44:13,920 --> 00:44:15,600
And I've got a rule here.

507
00:44:16,160 --> 00:44:19,840
I want to inventory my blobs and I want block and page and append.

508
00:44:20,160 --> 00:44:21,680
I could include versions.

509
00:44:22,160 --> 00:44:27,680
I can say what to store, how often I want to create the inventory, what format to output in.

510
00:44:28,160 --> 00:44:33,680
And then it's just going to go ahead and create me that data in my storage account.

511
00:44:36,280 --> 00:44:37,320
So I can give it full detail.

512
00:44:37,320 --> 00:44:40,560
It's going to put it in the inventory policy container.

513
00:44:40,560 --> 00:44:44,400
So if I look at my containers, I'll see inventory.

514
00:44:44,720 --> 00:44:47,440
I'll see these date-based folder structures get created.

515
00:44:47,440 --> 00:44:54,080
So I'm going to go inventory data of what my data actually looked like at any moment in time.

516
00:44:55,320 --> 00:45:16,240
Now, obviously, these files are going to mount up over time, so one of the things you may need to do is tidy that up, and we'll talk later on about a nice feature around lifecycle management, so you could absolutely automate clearing that stuff up, then you get into files, so these I can interact using the various REST APIs.

517
00:45:17,360 --> 00:45:21,240
But files gives me an SMB or NFS share.

518
00:45:21,240 --> 00:45:22,320
And that's one or the other.

519
00:45:22,640 --> 00:45:27,040
When I create a share, I say, is it SMB or is it NFS?

520
00:45:27,440 --> 00:45:32,280
So for SMB, it's going to be a 2.1 or ideally a 3.X.

521
00:45:32,280 --> 00:45:35,480
The exact version varies depending on the client of how I talk to it.

522
00:45:36,000 --> 00:45:41,200
But I think it supports up to 3.1.1 with server 2022 or Windows 11.

523
00:45:43,920 --> 00:45:44,320
Those.

524
00:45:44,640 --> 00:45:49,920
different with version 3, it's going to be using encryption, so I can even talk to it from outside the region.

525
00:45:50,960 --> 00:45:53,760
SMB supports a number of different options for the authentication.

526
00:45:53,760 --> 00:45:57,040
It has snapshot capabilities, so I can get those previous points in time.

527
00:45:57,200 --> 00:46:01,560
And they will actually surface within the Windows previous versions tab.

528
00:46:01,600 --> 00:46:03,600
So that's a really nice set of capabilities.

529
00:46:04,480 --> 00:46:10,560
But SMB, remember, is built on Windows, so it's really designed to interact and authenticate using Kerberos.

530
00:46:10,960 --> 00:46:22,400
So there's ways I can interact with if I have my existing Active Directory domain services, well, I can use that and my storage account will just get an object within my Active Directory domain services.

531
00:46:23,200 --> 00:46:25,840
Entra ID has a Kerberos capability.

532
00:46:26,000 --> 00:46:31,600
Maybe my client doesn't have line of sight to my domain controllers, or there's some special scenario.

533
00:46:31,840 --> 00:46:32,560
I can use that.

534
00:46:33,600 --> 00:46:40,800
If I don't have Active Directory domain services for these accounts, I can use the Entra domain services where it's a managed set of Active Directory.

535
00:46:41,400 --> 00:46:45,280
And then you'd have the various access control lists on the files and folders.

536
00:46:46,880 --> 00:46:51,760
NFS 4.1 is some of the core features.

537
00:46:52,080 --> 00:46:56,720
I can only use it from a trusted virtual network because there's no encryption at transit.

538
00:46:57,280 --> 00:47:00,160
And again, I have to pick that when I'm actually going ahead.

539
00:47:00,400 --> 00:47:03,840
Now, the NFS 4.1 is only if it's a premium files account.

540
00:47:04,160 --> 00:47:07,360
It's also designed to only be used from Linux.

541
00:47:07,680 --> 00:47:11,360
Windows is not supported to actually go and use that.

542
00:47:12,080 --> 00:47:18,680
So if I think about my services, okay, so we add BLOB, and now we also have files.

543
00:47:18,680 --> 00:47:23,680
And obviously files, we create a share.

544
00:47:25,840 --> 00:47:32,800
And at the share level, it is SMB or NFS.

545
00:47:33,360 --> 00:47:36,000
Remember, for NFS, it has to be premium.

546
00:47:39,120 --> 00:47:41,840
And then under the share, you create folders and files.

547
00:47:45,600 --> 00:47:49,200
So the standard stuff we're used to when we're dealing with file-based storage.

548
00:47:50,560 --> 00:47:54,560
Now, the next two things we're going to talk about, really are being de-emphasized.

549
00:47:55,760 --> 00:47:56,960
So we have tables.

550
00:47:57,360 --> 00:48:01,760
Tables are key value sets of data.

551
00:48:02,360 --> 00:48:03,600
There's kind of a NoSQL.

552
00:48:03,600 --> 00:48:04,880
There's no set schema.

553
00:48:05,440 --> 00:48:09,040
I have entities which are rows that can have whatever columns you want.

554
00:48:09,520 --> 00:48:13,760
But honestly, today, most customers are going to use Cosmos DB and its key value store.

555
00:48:14,160 --> 00:48:18,280
There's a partition key which controls how I shard the data, partition the data.

556
00:48:18,280 --> 00:48:23,680
And then the partition and the row key, they uniquely identified any particular record.

557
00:48:24,760 --> 00:48:26,080
And then we also have queues.

558
00:48:26,560 --> 00:48:27,920
Queues are just messages.

559
00:48:29,440 --> 00:48:32,000
But again, I could use service bus queues, which are better.

560
00:48:32,480 --> 00:48:34,240
It's a first in, first out.

561
00:48:34,240 --> 00:48:39,520
So the first thing you put in should be the first thing that comes out of the queue, but it's not guaranteed.

562
00:48:40,960 --> 00:48:42,640
With service bus, it is guaranteed.

563
00:48:43,840 --> 00:48:51,280
I can only do get, put, and peek, whereas service bus has much richer subscribe, publish as topic concepts, et cetera.

564
00:48:52,000 --> 00:48:54,240
And so these things exist.

565
00:48:54,640 --> 00:48:58,480
these tables and queues, but most people are starting to move away.

566
00:48:59,400 --> 00:49:01,120
There's not a lot of investment in them at all.

567
00:49:01,520 --> 00:49:08,720
So tables, hey, we have these entities that are these key value.

568
00:49:10,960 --> 00:49:16,880
And then we have queue, which are messages.

569
00:49:19,080 --> 00:49:23,440
But there's just honestly just better service available for those things.

570
00:49:24,000 --> 00:49:27,120
just to make sure everyone's clear on what those things kind of look like.

571
00:49:28,200 --> 00:49:35,360
If I go and look at my storage account and I go and look in the storage browser, so a file share, we're probably used to file shares.

572
00:49:36,080 --> 00:49:41,120
So I can see I've got a file share and I would see the content in it.

573
00:49:41,120 --> 00:49:43,360
I'm using entry identification.

574
00:49:44,320 --> 00:49:45,600
That's why it's going to be an issue right now.

575
00:49:45,840 --> 00:49:50,400
A queue, you have messages, but you put a message on the queue.

576
00:49:52,000 --> 00:49:53,360
Kind of things like a lifetime.

577
00:49:54,720 --> 00:49:56,560
And I can take stuff off the queue.

578
00:49:57,840 --> 00:49:59,280
First in, first out, and it's gone.

579
00:50:00,240 --> 00:50:02,560
Tables, there's no schema.

580
00:50:03,040 --> 00:50:04,880
I just add values to it.

581
00:50:05,600 --> 00:50:13,960
And if I add an entity, it will show me things that have been used before from other objects.

582
00:50:13,960 --> 00:50:15,680
So it's helping me save some time.

583
00:50:16,080 --> 00:50:17,800
But I can add other properties I want.

584
00:50:17,800 --> 00:50:20,080
I don't have to enter any of those things.

585
00:50:20,800 --> 00:50:22,120
So there's no set schema.

586
00:50:22,120 --> 00:50:26,120
I can kind of add and remove things just as I choose to.

587
00:50:26,120 --> 00:50:28,840
So I'm going to look at particularly entity there.

588
00:50:29,840 --> 00:50:36,960
And those are the values I happen to put in, those key, the key, the age, the value 24, key, the alias, value, the flash.

589
00:50:37,600 --> 00:50:43,760
But once again, the Cosmos DB set of capabilities around this are just far, far richer today.

590
00:50:43,920 --> 00:50:47,520
So the queues and the tables are just not heavily used.

591
00:50:49,040 --> 00:50:54,320
Now, you may be wondering, especially for the queue thing, is like, when would I use queues?

592
00:50:54,800 --> 00:50:57,200
Then imagine I had some event-driven process.

593
00:50:57,600 --> 00:51:03,040
So something comes in, I can drop a message on a queue, saying, oh, we received this thing.

594
00:51:03,680 --> 00:51:13,120
Something else, some event-driven capability would then see the message, and then maybe read in some ID, and then go and look and grab the actual object and do something.

595
00:51:13,600 --> 00:51:25,000
So in an event-driven architectures, it's really common to use that queue concept to trigger that serverless Azure function or Logic App or whatever you want to then go and do something with it.

596
00:51:26,560 --> 00:51:27,200
Money.

597
00:51:28,560 --> 00:51:30,400
Obviously, money is very, very important.

598
00:51:31,440 --> 00:51:36,080
So standard performance and BLOB premium is consumption-based.

599
00:51:36,720 --> 00:51:41,600
So what that means is I'm paying for the amount of

600
00:51:42,240 --> 00:51:50,640
Actual capacity I'm using, and then I'm paying for the type of transactions that I perform against it.

601
00:51:51,840 --> 00:52:10,000
So, if we go and look at the pricing page for this, and you can see I've got the hierarchical namespace, or it could just be the flat namespace, but from a pricing perspective, you're paying for the amount of storage.

602
00:52:10,720 --> 00:52:13,040
Let's actually change it to the flat for a second.

603
00:52:13,040 --> 00:52:14,320
So that's hierarchical.

604
00:52:14,960 --> 00:52:17,760
Flat is basically the same price, I think.

605
00:52:18,160 --> 00:52:23,320
There's a tiny bit of a price difference, tiny, tiny.

606
00:52:23,320 --> 00:52:27,840
And then you pay for the operations.

607
00:52:28,160 --> 00:52:32,280
Write operations list, read operations, data retrieval, data write.

608
00:52:32,720 --> 00:52:37,360
So I'm basically paying for the work I am actually doing.

609
00:52:38,000 --> 00:52:41,920
So that's one of the key capabilities around this.

610
00:52:42,800 --> 00:52:46,480
Now, you'll notice one of the key things here, and I mentioned this earlier.

611
00:52:47,280 --> 00:52:50,080
So the capacity prices are varying.

612
00:52:52,440 --> 00:52:57,120
Based on this, is it premium or then is it hot, cool, cold, and there's an archive?

613
00:52:57,600 --> 00:53:02,000
And it's more expensive, obviously, the better the service, which you would kind of expect.

614
00:53:03,480 --> 00:53:07,440
If I look at the operations, the operations are the opposite.

615
00:53:08,080 --> 00:53:14,680
So they're cheaper the better it is, and they get more expensive the lower that tier becomes.

616
00:53:14,680 --> 00:53:19,440
And then you have archive is an exception because archive is basically offline.

617
00:53:20,400 --> 00:53:25,440
Archive is, hey, I need to keep this stuff, but I don't need media access to it.

618
00:53:26,080 --> 00:53:36,800
So a key point on this element is for BLOB and files, pay-as-you-go tiering,

619
00:53:38,000 --> 00:53:42,080
impacts the capacity versus the operational cost.

620
00:53:42,560 --> 00:53:59,360
So those tiering capabilities let me tweak, hey, do I want to pay more for the capacity, but I know I'm going to be interacting with me at a certain amount, so I'll pay less for the actual transactions compared to, hey, look, I know I'm not going to be interacting with this stuff very much, but I need it available.

621
00:53:59,520 --> 00:54:02,880
So I want to pay the absolute minimum to store the thing,

622
00:54:03,480 --> 00:54:08,640
and I'm willing to pay more money for if I do actually have to interact with it.

623
00:54:10,160 --> 00:54:13,080
So the way this works is, let's come up here.

624
00:54:14,160 --> 00:54:17,600
So we have different things for BLOB and files.

625
00:54:18,240 --> 00:54:20,960
So we'll start off looking at Block BLOB.

626
00:54:21,840 --> 00:54:30,560
So if I think Block BLOB, an important thing for Block BLOB is the tier is set per BLOB.

627
00:54:33,040 --> 00:54:37,120
So many different blobs within the same container can have different tier levels.

628
00:54:37,760 --> 00:54:44,480
And when we think about what our options are, one of the important things is, remember, premium doesn't have tierings.

629
00:54:44,720 --> 00:54:46,880
Premium is its own type of account.

630
00:54:47,040 --> 00:54:50,320
But I might choose premium because I need really high performance.

631
00:54:51,040 --> 00:54:55,440
And again, I pay more for the capacity, but I pay a lot less for the operations against it.

632
00:54:56,000 --> 00:55:00,800
So I can think about, I have the nice premium capability up here.

633
00:55:01,040 --> 00:55:02,560
Make sure I give myself enough space, actually.

634
00:55:02,880 --> 00:55:04,000
I know I've got to draw later on.

635
00:55:04,320 --> 00:55:16,640
So I might have premium here, but then I have the concept of just the standard type of account.

636
00:55:17,680 --> 00:55:21,440
But within the standard type of account, well, I have a hot tier.

637
00:55:24,960 --> 00:55:27,000
I have a cool tier.

638
00:55:27,000 --> 00:55:28,400
I don't know what color to use for cool.

639
00:55:28,400 --> 00:55:29,680
Here we use cool tier.

640
00:55:32,400 --> 00:55:33,720
I have a cold tier.

641
00:55:33,720 --> 00:55:39,040
And then we have an archive tier.

642
00:55:39,840 --> 00:55:48,960
So the archive tier is, well, the best archive and what we're kind of used to is it's barely available.

643
00:55:49,200 --> 00:55:54,080
Like it's going to keep the data for us, but I can't interact with it live.

644
00:55:54,720 --> 00:55:56,320
So this is actually offline.

645
00:55:57,200 --> 00:56:04,720
So maybe I've got some data retention scenario where I have to keep data for seven years, but I have almost 0 intention of having to interact with it.

646
00:56:05,600 --> 00:56:07,440
So I could put it into archive.

647
00:56:07,440 --> 00:56:16,560
I pay almost no money, but if I do then need to read it, I have to rehydrate it back into another tier, and then I can access it.

648
00:56:17,440 --> 00:56:20,800
That's why they introduced cold, because originally it was hot, cold and archive.

649
00:56:21,120 --> 00:56:28,040
Cold was introduced for saying, hey, I can't wait maybe 24 hours to move the data back into an online tier.

650
00:56:28,560 --> 00:56:33,120
So cold is even cheaper, but it's still online immediately.

651
00:56:33,920 --> 00:56:43,040
And when I think about these different options, remember then from a money perspective, I have the amount of money I pay for the capacity.

652
00:56:43,440 --> 00:56:46,720
So how much do I pay for the actual storage?

653
00:56:47,120 --> 00:56:56,880
So I pay absolutely the most for premium, and I pay absolutely the least as I go down to kind of this archive scenario.

654
00:56:57,200 --> 00:57:04,960
So the price I pay for the capacity gets less and less as I go down the tiers.

655
00:57:05,680 --> 00:57:15,360
But the price of the operations, when I need to actually do something, well, I have to actually bring it back, but I pay a lot more

656
00:57:18,160 --> 00:57:19,920
compared to it's very cheap up here.

657
00:57:20,480 --> 00:57:22,720
So it's all about your choice.

658
00:57:24,880 --> 00:57:28,640
And that's obviously going to change over time as the data gets older and older.

659
00:57:28,960 --> 00:57:35,680
So it's very common that what I actually want to do is start moving data maybe down tiers.

660
00:57:35,680 --> 00:57:38,480
And many people put stuff in hot and it just doesn't need to be in hot.

661
00:57:38,960 --> 00:57:41,120
It can actually live in cold quite happily.

662
00:57:41,760 --> 00:57:45,520
but it can be hard to know what is the right option for that.

663
00:57:46,400 --> 00:57:49,760
So that's my block BLOB is based around those.

664
00:57:51,520 --> 00:57:58,400
And then for files, we have similar capabilities.

665
00:57:59,280 --> 00:58:07,120
But if I think about files, I'm going to focus here on the pay go.

666
00:58:07,200 --> 00:58:09,040
So this is my pay as you go.

667
00:58:11,760 --> 00:58:14,480
because there's a new provisioned option we're going to talk about.

668
00:58:14,960 --> 00:58:20,000
Now the big deal here is for the tiers for files, it is a share setting.

669
00:58:20,000 --> 00:58:21,360
It is not a profile.

670
00:58:21,600 --> 00:58:23,680
So this is a share setting.

671
00:58:27,280 --> 00:58:29,360
And now we have three options.

672
00:58:29,760 --> 00:58:37,520
So we have the idea of, obviously there is the premium kind of option again for PAYGO files.

673
00:58:38,320 --> 00:58:47,680
But then we have within the standard option, imagine there's a line here that makes up these things.

674
00:58:47,680 --> 00:58:48,560
Let's just move this.

675
00:58:48,880 --> 00:58:50,000
Oh, come on.

676
00:58:50,880 --> 00:58:51,440
Do a good job.

677
00:58:51,600 --> 00:58:52,560
Oh, no, there we go.

678
00:58:52,720 --> 00:58:52,880
No.

679
00:58:54,320 --> 00:58:55,200
Technical difficulties.

680
00:58:55,200 --> 00:58:55,560
There we go.

681
00:58:55,760 --> 00:58:58,080
So imagine that line is going across.

682
00:58:59,040 --> 00:59:02,560
Within the regular, we have three options.

683
00:59:03,040 --> 00:59:06,240
So I can do transaction optimized.

684
00:59:12,880 --> 00:59:13,920
Then we can do hop.

685
00:59:17,280 --> 00:59:18,240
And then we can do call.

686
00:59:19,600 --> 00:59:22,640
So we have those various options available to us.

687
00:59:23,200 --> 00:59:25,240
But I have to configure that on the share.

688
00:59:25,240 --> 00:59:32,800
But once again, transaction optimized, I'll pay the most for the capacity, but at least for the operations, all the way going down to call.

689
00:59:33,320 --> 00:59:35,040
And if we look at a storage account,

690
00:59:38,880 --> 00:59:52,000
So if I looked at my containers for a second and looked at images, notice my access tier, I've got some files that are hot, some are cool, some are cold, some are actually in archive.

691
00:59:53,040 --> 00:59:59,960
And the one that is in archive, if I look at the hot one, I could get the...

692
01:00:00,080 --> 01:00:00,560
file.

693
01:00:00,560 --> 01:00:01,360
It's letting me do it.

694
01:00:02,160 --> 01:00:08,320
If I try and look at the one that's archived, it's grayed out.

695
01:00:09,360 --> 01:00:12,320
It's currently archived and cannot be downloaded.

696
01:00:12,400 --> 01:00:14,240
I would have to rehydrate it.

697
01:00:14,640 --> 01:00:22,000
So I'd have to go and change the tier and move it into something else and that will take time and then I'd be out.

698
01:00:22,000 --> 01:00:22,960
So it's not instant.

699
01:00:23,320 --> 01:00:26,480
I think it's up to 24 hours it can take to do those operations.

700
01:00:27,120 --> 01:00:28,480
Any of these at any time?

701
01:00:28,960 --> 01:00:30,640
I can change it very easy.

702
01:00:30,640 --> 01:00:32,160
So it's a per file level.

703
01:00:32,720 --> 01:00:40,720
For shares, so if I go to file shares, when I create the share, that's when I have to pick.

704
01:00:42,000 --> 01:00:44,000
So it's a share level setting.

705
01:00:44,520 --> 01:00:53,520
And once again, you're going to balance that with my intended interactions with it.

706
01:00:53,920 --> 01:00:56,080
So if I look at the pricing for files,

707
01:00:57,920 --> 01:01:05,920
You can see, if we look at the provisioned V1, so that's premium, let's just do paygo.

708
01:01:05,920 --> 01:01:22,560
Here we go, so the storage I pay less as I move from hot, sorry, to transaction optimize hot call, so it's cheaper to store it, but when I actually then do operations against it.

709
01:01:23,120 --> 01:01:25,720
It's really cheap for that transaction optimizing.

710
01:01:25,720 --> 01:01:28,560
It's more expensive as I move down the tiers.

711
01:01:28,800 --> 01:01:42,600
So just think of these always as ways for you as the customer to optimize what I want to pay for depending on what is my planned set of interactions with these things.

712
01:01:42,600 --> 01:01:49,200
So the tiers are there for you so you can optimize actually how I want to pay the money.

713
01:01:49,200 --> 01:01:50,960
So there's some work involved in that.

714
01:01:51,680 --> 01:01:55,440
and there's going to be some investigation to what is actually the right thing.

715
01:01:57,040 --> 01:02:00,880
Now, remember, that was for the standard performance and blog premium.

716
01:02:00,880 --> 01:02:02,160
It's consumption-based.

717
01:02:02,480 --> 01:02:08,560
So I'm going to pay for the capacity and I'm going to pay for the operations.

718
01:02:10,160 --> 01:02:15,920
Files premium and page blog premium are provision-based, i.e.

719
01:02:16,240 --> 01:02:19,920
I pay for the amount of capacity I provision for the service,

720
01:02:20,720 --> 01:02:23,600
not based on the amount I'm actually using.

721
01:02:24,960 --> 01:02:28,960
So I say, hey, I want 100 GB premium file share.

722
01:02:29,360 --> 01:02:31,600
I pay for 100 GB premium file share.

723
01:02:31,600 --> 01:02:32,320
It doesn't matter.

724
01:02:32,320 --> 01:02:33,600
I've got 10 megs stored in it.

725
01:02:33,920 --> 01:02:36,760
I'm paying for the provisioned size of it.

726
01:02:36,760 --> 01:02:37,840
That's the important point.

727
01:02:38,400 --> 01:02:45,280
And then the performance, the performance is going to scale based on the amount of capacity.

728
01:02:45,520 --> 01:02:48,360
So I may pick a capacity much bigger than I want,

729
01:02:48,880 --> 01:02:51,680
because I need the performance that gets associated with it.

730
01:02:52,320 --> 01:03:16,560
So for files premium and for the page BLOB premium, what we're doing here is it's based on, if I have a chart, I am telling it

731
01:03:17,160 --> 01:03:18,640
the amount of capacity.

732
01:03:19,040 --> 01:03:26,240
And the money I'm paying is based on the provisioned size.

733
01:03:26,640 --> 01:03:27,920
That's what I pay for.

734
01:03:28,480 --> 01:03:31,040
Doesn't matter if I'm only using 1% of it.

735
01:03:31,120 --> 01:03:32,320
I pay the full amount.

736
01:03:32,720 --> 01:03:44,400
Because the performance, think the IOPS, the throughput, that is going to scale based on the capacity.

737
01:03:45,680 --> 01:03:58,800
And so I may provision a certain size because I need this amount of storage, or I may provision this amount of size because I need the correlating performance.

738
01:03:59,520 --> 01:04:04,160
And that's why it doesn't care how much you use, because you may not be creating it as that size for the capacity.

739
01:04:04,880 --> 01:04:06,000
It's just a byproduct.

740
01:04:06,000 --> 01:04:08,720
What I actually need is the associated performance of it.

741
01:04:09,200 --> 01:04:12,320
So that's a big difference here, and it's important to know that.

742
01:04:13,480 --> 01:04:14,440
How am I being charged?

743
01:04:14,440 --> 01:04:18,280
Is it based on what I put in the thing or is it based on the provision size?

744
01:04:18,280 --> 01:04:24,320
And I pick that when I go and actually create that particular account, create that go, that share.

745
01:04:24,560 --> 01:04:28,720
So it's important you understand the difference between how those things are actually built.

746
01:04:30,240 --> 01:04:36,400
And then there is this new regular, today it's regular.

747
01:04:36,880 --> 01:04:41,280
So standard performance files provisioned V2.

748
01:04:42,320 --> 01:04:44,720
Now this I have to pick when I create the storage account.

749
01:04:45,520 --> 01:04:51,520
And now I separately pay for the provision capacity, the IOPS, and the throughput.

750
01:04:51,920 --> 01:04:55,200
And I can dynamically change this at any time.

751
01:04:55,760 --> 01:04:58,640
So now this is the file, oops, don't want to do that color.

752
01:04:59,600 --> 01:05:11,680
So this is files today standard, but it is this provisioned V2.

753
01:05:12,400 --> 01:05:14,240
And now I just think about it as three dials.

754
01:05:14,640 --> 01:05:17,760
I have one dial where I tell it the amount of capacity.

755
01:05:19,440 --> 01:05:22,800
I have another dial where I tell it the amount of IOPS.

756
01:05:23,600 --> 01:05:27,280
And I have another dial that is the amount of throughput I want.

757
01:05:28,000 --> 01:05:32,840
And I pay for what I set each of those dials to.

758
01:05:32,840 --> 01:05:39,760
And the nice thing is the IOPS and the throughput are dynamic.

759
01:05:42,560 --> 01:05:45,960
So I can change the IOPS, I can change the throughput when I want.

760
01:05:46,480 --> 01:05:53,040
Now, if I increase the IOPS or the throughput, I have to wait 24 hours before I can lower it again.

761
01:05:53,680 --> 01:05:57,600
But I would absolutely expect this model to be coming to the premium files as well.

762
01:05:57,600 --> 01:06:05,760
So this gives you a lot more flexibility as the customer in what I'm paying for and how I want to pay.

763
01:06:06,120 --> 01:06:09,040
But just realize for Azure Storage, there are differences.

764
01:06:09,360 --> 01:06:10,320
between how they're built.

765
01:06:10,640 --> 01:06:19,760
So take some time to understand that, to make sure you're picking the right thing based on the performance I need, and I'm optimizing what I'm actually paying for.

766
01:06:21,560 --> 01:06:23,600
And also remember, don't forget about data transfer.

767
01:06:24,240 --> 01:06:32,720
So when I have things that replicate to another region, there's still underlying network egress costs that I have to pay for as well.

768
01:06:33,160 --> 01:06:34,560
I think these get shown.

769
01:06:35,200 --> 01:06:36,000
Let's have a quick look.

770
01:06:37,360 --> 01:06:44,400
So if I, actually while we're here, I guess, so we're looking at files, this is the provision V2.

771
01:06:44,800 --> 01:06:51,760
And notice it's just bill based on the amount of provisioned storage, the amount of provisioned IOPS, and the amount of provisioned throughput.

772
01:06:52,960 --> 01:06:56,240
But if I change this to GRS, let's see.

773
01:06:59,040 --> 01:07:00,160
I know it shows it for BLOB.

774
01:07:00,160 --> 01:07:03,520
Oh, here we go, data transfer.

775
01:07:03,520 --> 01:07:03,920
There we go.

776
01:07:06,560 --> 01:07:10,240
This is the bandwidth used to replicate data to the secondary Azure region.

777
01:07:10,560 --> 01:07:11,840
So I pay for that.

778
01:07:11,840 --> 01:07:21,920
So just realize when I think of all the different costs, there's also the network costs associated when I'm sending the data across the region.

779
01:07:21,920 --> 01:07:26,720
So if I'm planning my things out, I don't want to forget about any of those individual components.

780
01:07:26,960 --> 01:07:30,000
So just make sure you have that as part of your plan.

781
01:07:30,160 --> 01:07:31,440
Just an important point there.

782
01:07:33,040 --> 01:07:33,440
Okay.

783
01:07:34,880 --> 01:07:35,280
So

784
01:07:36,640 --> 01:07:38,080
I mentioned the data lake.

785
01:07:38,240 --> 01:07:39,640
So Azure Data Lake Storage Gen.

786
01:07:39,640 --> 01:07:40,960
1 was a completely different service.

787
01:07:40,960 --> 01:07:42,960
It did not do very well.

788
01:07:43,680 --> 01:07:46,080
So Azure Data Lake Storage Gen.

789
01:07:46,080 --> 01:07:48,080
2 builds on BLOB.

790
01:07:48,480 --> 01:07:52,560
It adds that true hierarchical namespace to a true directory structure.

791
01:07:53,200 --> 01:07:55,520
And again, I can store really anything in this.

792
01:07:56,000 --> 01:08:01,520
I could store parquet files, Avro, database tables, so I could store structured data.

793
01:08:02,320 --> 01:08:06,960
it's very common to use the Parquet, so it's that column-based storage.

794
01:08:07,440 --> 01:08:13,440
I could store semi-structured, I could put JSON files, I could put XML in it, I could put unstructured media, anything I want.

795
01:08:14,880 --> 01:08:26,720
I get a lot of the BLOB features, like tiering, there's premium options, there's lifecycle management, but it's not all features.

796
01:08:26,880 --> 01:08:30,400
So if I go and click this for a second and we jump over and look,

797
01:08:31,200 --> 01:08:38,480
This will tell me which features of BLOB is supported when I turn on the hierarchical namespace.

798
01:08:38,480 --> 01:08:41,360
And some of them are just not supported and some are in preview.

799
01:08:42,440 --> 01:08:46,800
And so if we go and look, so I can see access tiers.

800
01:08:46,880 --> 01:08:48,320
Yep, I've got access tiers.

801
01:08:48,320 --> 01:08:51,200
Good, I do not have BLOB index tags.

802
01:08:53,360 --> 01:08:56,320
I have some limited BLOB snapshots.

803
01:08:57,920 --> 01:08:59,360
Do not have custom domains.

804
01:09:00,000 --> 01:09:01,680
Do not have customer provided keys.

805
01:09:01,920 --> 01:09:07,760
Do not have object level replication.

806
01:09:08,320 --> 01:09:10,800
Do not have point in time restore for block blobs.

807
01:09:12,320 --> 01:09:16,160
So there are some things that are missing, but you can see it's pretty complete.

808
01:09:16,400 --> 01:09:27,920
But again, I would go and look and say, well, what are the capabilities I actually need to know exactly, well, what is going to be useful for me to go and leverage this actual data lake?

809
01:09:28,720 --> 01:09:34,240
But typically with a data lake, it's some raw store.

810
01:09:34,800 --> 01:09:47,920
If I think of data pipelines today, so data pipelines are very much used to maybe get data in from a system, do something to the data, and then send it to something else, maybe for analytics, maybe for other processing.

811
01:09:48,880 --> 01:09:57,040
Well, very often today, what I want to do is before I process the data, the raw source, I just go and store in a data lake.

812
01:09:57,600 --> 01:09:57,920
Because

813
01:09:58,800 --> 01:10:00,240
Storage has got a lot cheaper.

814
01:10:00,480 --> 01:10:05,080
It used to be in the old days, storage was so, expensive.

815
01:10:05,080 --> 01:10:10,080
And so one of the things I would have to do is, well, I can't afford to just store the data as is.

816
01:10:10,080 --> 01:10:11,760
It's way too expensive.

817
01:10:12,160 --> 01:10:21,840
And so what we would have to do is transform it, get it down to the minimum possible amount of data, and then we'd store it somewhere, because those ones and zeros on disk were really, really expensive.

818
01:10:23,200 --> 01:10:24,320
That is not the case anymore.

819
01:10:24,960 --> 01:10:27,360
Today, storage is actually very, very cheap.

820
01:10:28,320 --> 01:10:31,280
And so here, if I think about, I have my data lake.

821
01:10:32,640 --> 01:10:34,320
So I've got my nice little data lake.

822
01:10:36,800 --> 01:10:53,840
Because I turned on the hierarchical namespace, what is super common today in my pipeline is instead of extract the data, transform it, and then load it into something, it's really common today to as the raw data comes in, we just dump it in the data lake.

823
01:10:54,320 --> 01:10:54,800
as is.

824
01:10:54,880 --> 01:10:55,840
Just store it.

825
01:10:56,320 --> 01:10:57,840
Because storage is so cheap.

826
01:10:58,400 --> 01:11:12,000
And what's nice about this is if we store it before we transform it and maybe normalize it and validate it and throw stuff away, maybe tomorrow I have a different use case for the data.

827
01:11:12,480 --> 01:11:18,800
Well, if I've only stored the transform stuff, I've lost the stuff we pruned or checked away.

828
01:11:19,400 --> 01:11:31,440
If I store the raw data at any time in the future, I can come back to the data lake and do a new type of analysis, a new type of transformation that I didn't think about at the time, but I have it all there.

829
01:11:32,000 --> 01:11:41,840
So this is why data lakes are so appealing, but we want that very good cost efficiency because it lets us do analysis that I have not yet thought about.

830
01:11:42,400 --> 01:11:46,720
Now, because it's built on BLOB, well, I can use...

831
01:11:48,240 --> 01:11:49,520
all of the BLOB APIs.

832
01:11:50,960 --> 01:11:52,680
So we get a lot of flexibility in the tooling.

833
01:11:52,680 --> 01:11:54,240
I can use a BLOB API against it.

834
01:11:55,040 --> 01:12:01,760
But also what we have is we have a DFS driver, so a distributed file system API.

835
01:12:02,080 --> 01:12:06,920
So there's a DFS API that I can use to interact with this.

836
01:12:06,920 --> 01:12:13,120
And what we also then have is things like Hadoop, Spark, Databricks.

837
01:12:13,600 --> 01:12:16,880
They have an ABFS driver which talks to the DFS driver.

838
01:12:17,120 --> 01:12:26,560
This is just a fancy way of saying, I can talk to this through standardized APIs that our data analysis solutions expect to use.

839
01:12:26,880 --> 01:12:32,880
So again, that Hadoop, Spark, Databricks, they can all go and plug into this and leverage these sets of capabilities.

840
01:12:32,880 --> 01:12:36,560
So that's a really great thing that we have the option of doing.

841
01:12:39,680 --> 01:12:43,280
Again, it gives us that true hierarchical namespace.

842
01:12:43,280 --> 01:12:49,840
Now, I mentioned before that BLOB, regular block BLOB, you see folders, but it's really just part of the file name.

843
01:12:49,880 --> 01:12:51,520
And you might say, well, who cares?

844
01:12:51,520 --> 01:12:54,000
It looks like a true folder structure to me.

845
01:12:55,040 --> 01:13:04,560
But if I actually try to, for example, move a folder, a file between those virtual directories in regular BLOB, there is no move operation.

846
01:13:05,120 --> 01:13:10,080
it has to copy all those blocks to a new file and then delete the old one.

847
01:13:10,400 --> 01:13:15,200
So if I had a really big file and I moved it to another folder, it's a copy and delete.

848
01:13:15,360 --> 01:13:17,600
So it's a massive, massive operation.

849
01:13:18,080 --> 01:13:22,800
Whereas with the true directory structure, it's an actual metadata change.

850
01:13:23,040 --> 01:13:25,200
So those moves are super fast.

851
01:13:25,560 --> 01:13:32,720
And very often in like data analytics, we may go and move it between places based on the actual processing stage it's in.

852
01:13:34,480 --> 01:13:37,040
You also, I guess I should go back to my PowerPoint here.

853
01:13:40,680 --> 01:13:49,040
You get the true structure, you get those, you get POSIX style ACLs, so I can do the types of access control I'm used to.

854
01:13:49,880 --> 01:13:58,000
I can also use Entra ID identities as part of those access control lists we're putting on top of this.

855
01:13:58,400 --> 01:14:03,520
If we went and looked at one of these, for example, so I've got the data lake turned on,

856
01:14:05,520 --> 01:14:09,280
on, if I can find it, let's see, ADLS, I think.

857
01:14:10,800 --> 01:14:11,200
There we go.

858
01:14:12,720 --> 01:14:22,640
So on this one, if I go and look at my storage, you notice I've got some kind of different options over here.

859
01:14:25,120 --> 01:14:26,960
I've actually got manage ACLs.

860
01:14:27,280 --> 01:14:32,960
So you see I've got these POSIX style owner super user, owning group super user.

861
01:14:33,200 --> 01:14:34,680
I can go and add additional principles.

862
01:14:34,680 --> 01:14:36,480
I can go and add masks to this.

863
01:14:37,040 --> 01:14:43,920
So I get a different set of permission capabilities because I've turned on that hierarchical namespace.

864
01:14:44,560 --> 01:14:56,000
So if I have a workload that is designed for use with a true file system that wants to go and manipulate directories, for example, then the hierarchical namespace is going to make a lot more sense to you.

865
01:14:57,760 --> 01:15:01,360
And that's going to be a huge benefit to that particular workload.

866
01:15:02,080 --> 01:15:05,520
Now, from a cost perspective, it's built on BLOB.

867
01:15:06,160 --> 01:15:10,640
And so it will always cost the same or more.

868
01:15:10,640 --> 01:15:12,080
It should never be cheaper than BLOB.

869
01:15:12,240 --> 01:15:13,440
It's sitting on top of BLOB.

870
01:15:13,440 --> 01:15:19,600
So if you're trying to work out the pricing, and you saw in the pricing page, it gave me the hierarchical namespace versus the flat namespace.

871
01:15:19,920 --> 01:15:22,000
It's the hierarchical namespace pricing.

872
01:15:22,320 --> 01:15:23,200
That's what you're going to get.

873
01:15:23,280 --> 01:15:24,640
But any type of analytics,

874
01:15:24,960 --> 01:15:33,600
Any type of data transformations, Data Lake's fantastic for doing that basically dump of the raw data.

875
01:15:34,080 --> 01:15:38,680
And even beyond raw data, I can actually go and use it for many other things.

876
01:15:38,680 --> 01:15:39,920
It's very highly performant.

877
01:15:40,040 --> 01:15:45,360
Again, I can put those parquet files in it, for example, as a store for my database.

878
01:15:47,040 --> 01:15:48,160
Hosting a website.

879
01:15:49,840 --> 01:15:52,840
So if I only have static content,

880
01:15:53,440 --> 01:15:58,200
HTML, JavaScript, cascading style sheets, images, i.e.

881
01:15:58,200 --> 01:16:06,160
it's all pre-rendered content that just gets sent to the web browser, the client, and it doesn't require any brain on the server side.

882
01:16:06,400 --> 01:16:09,120
There is no computation to generate the content.

883
01:16:09,600 --> 01:16:11,840
Well, then I can host it via BLOB.

884
01:16:12,880 --> 01:16:18,400
Basically, all I have to do is at the account level, my storage account level, I can enable a static website.

885
01:16:18,960 --> 01:16:20,560
It shows me the URL.

886
01:16:22,000 --> 01:16:28,320
And it's going to create a dollar web folder where I put my content, and that's it.

887
01:16:28,400 --> 01:16:30,720
It's then going to get made available to us.

888
01:16:31,600 --> 01:16:38,800
Now, if we jump over and have a quick look, so looking at my storage account, let's just go back to a regular storage account for a second.

889
01:16:44,320 --> 01:16:49,760
So, if we scroll down, we have this option.

890
01:16:50,720 --> 01:16:54,480
data management, static website.

891
01:16:56,400 --> 01:16:58,080
And we basically just say, yeah, we want it.

892
01:16:58,080 --> 01:16:59,160
So I'm going to say enabled.

893
01:16:59,160 --> 01:17:02,120
It's giving us what the URL is.

894
01:17:02,120 --> 01:17:05,440
And if it was GRS, we have a secondary endpoint as well.

895
01:17:05,680 --> 01:17:08,080
We're telling it the index name and the error page.

896
01:17:08,080 --> 01:17:09,600
So I'll just copy this.

897
01:17:10,480 --> 01:17:15,120
But if I go and look at my containers, I'll see a dollar web.

898
01:17:16,360 --> 01:17:17,840
And I just dump my content into it.

899
01:17:18,240 --> 01:17:23,280
Again, there's no true folders, but I can still create a subfolder, which again will be part of the BLOB name.

900
01:17:23,280 --> 01:17:24,480
It's not going to be a problem.

901
01:17:25,120 --> 01:17:30,720
But then I can just dump in the URL and marvel at my fantastic website I created.

902
01:17:31,120 --> 01:17:33,120
I don't even know if 90s is the right word for this.

903
01:17:33,760 --> 01:17:42,400
But again, there's no server-side rendering, as long as it's all just stuff that the web client has to render.

904
01:17:43,960 --> 01:17:46,800
This is a pretty easy option to leverage.

905
01:17:48,240 --> 01:17:52,240
Now, this is a super, super basic option.

906
01:17:53,160 --> 01:17:56,960
And realistically, I can put a vanity domain in front of it.

907
01:17:57,120 --> 01:18:03,360
So I could absolutely have an ADS record in my own domain that points to this DNS name.

908
01:18:04,000 --> 01:18:05,920
But there's a thing called Azure Static Web Apps.

909
01:18:06,400 --> 01:18:09,200
These are actually typically free or very cheap.

910
01:18:09,600 --> 01:18:27,920
It also integrates with the content delivery network, so what that means is, whereas the storage account lives within a certain region, the content delivery network has points of presence and copies all around the world, so my client who's using it would talk to someone closer to them, so they'd actually get a better experience.

911
01:18:28,480 --> 01:18:32,720
Now, Azure Static Web Apps is also pre-rendered content only, but...

912
01:18:33,280 --> 01:18:38,320
It can hook in really easily into managed Azure functions if I do want some server-side processing.

913
01:18:38,320 --> 01:18:44,000
So while this is nice, honestly, I'd probably just use Azure Static Web Apps instead.

914
01:18:46,000 --> 01:18:47,040
Access control.

915
01:18:47,680 --> 01:18:52,320
So we have different options for how I can control talking to the data.

916
01:18:52,320 --> 01:18:57,360
Control plane, that's just regular Azure control plane, role-based access control.

917
01:18:57,840 --> 01:19:02,560
But for the actual talking to the data in the storage account, we have some different options.

918
01:19:03,280 --> 01:19:10,480
The first one is there are two all-powerful storage account keys, which ideally you do not use.

919
01:19:11,800 --> 01:19:20,720
If I go into my storage account and I look at my security and networking, you will see access keys.

920
01:19:22,160 --> 01:19:22,960
There were two of them.

921
01:19:25,320 --> 01:19:26,400
And they're all powerful.

922
01:19:26,480 --> 01:19:33,600
With these access keys talking to the data plane, I can talk to anything and do anything within the storage account.

923
01:19:33,800 --> 01:19:36,880
Now, you'll notice there were two of them, key one and key two.

924
01:19:37,640 --> 01:19:40,800
And you'll also notice there's the option to rotate the key.

925
01:19:41,120 --> 01:19:47,200
So periodically, if I was using it, I would want to rotate it, unlike me that did it 1000 days ago.

926
01:19:47,360 --> 01:19:47,680
Whoops.

927
01:19:48,720 --> 01:19:49,440
I don't use them.

928
01:19:51,280 --> 01:19:55,200
Or if you thought it being compromised, if someone knew it in some way, you would rotate it.

929
01:19:55,680 --> 01:20:01,760
Now, the reason we have two of these keys is think about for a second my storage account.

930
01:20:01,760 --> 01:20:03,200
Let's go give myself some space.

931
01:20:03,920 --> 01:20:04,960
So I've got my storage account.

932
01:20:06,960 --> 01:20:19,280
And let's say, for example, on this storage account, we're going to deal with how do I control the access control of the data plane I'm really focused on here.

933
01:20:20,080 --> 01:20:24,080
So we have key one and we have key two.

934
01:20:25,040 --> 01:20:27,920
And both of them have the ability to rotate the key.

935
01:20:28,480 --> 01:20:38,240
So if I had to rotate the key, if I have an application using the key to talk to the storage account, well, while I'm rotating it, the application would break.

936
01:20:38,880 --> 01:20:41,760
So the point here is I have two.

937
01:20:41,840 --> 01:20:46,960
So if I plan to rotate key one, the app would switch to use key two.

938
01:20:47,760 --> 01:20:51,760
And then after key one is rotated, I update the app to now use key one.

939
01:20:52,080 --> 01:20:55,920
So in the future, I could rotate key two without any interruption to my clients.

940
01:20:56,320 --> 01:21:01,040
So we have that option so I can do the nice rotation without breaking anything.

941
01:21:01,360 --> 01:21:03,280
But there is no granularity here.

942
01:21:03,840 --> 01:21:05,360
I can do everything.

943
01:21:05,520 --> 01:21:08,160
And because it's an access key, there's no good audit.

944
01:21:08,640 --> 01:21:14,000
If multiple people are using it, how do I know which actual process or person

945
01:21:15,440 --> 01:21:19,680
actually did the thing because the auditing is just going to show the access key was used.

946
01:21:20,240 --> 01:21:21,760
So it's really not a good idea.

947
01:21:22,480 --> 01:21:26,560
I can set a reminder if I wanted to on that key rotation.

948
01:21:27,080 --> 01:21:31,200
If I have to use the key, ideally put it in a key vault.

949
01:21:32,000 --> 01:21:33,760
Definitely never ever put it in code.

950
01:21:33,920 --> 01:21:35,800
That's going to apply to everything we talk about.

951
01:21:35,800 --> 01:21:40,800
And then I could use role-based access controls on the secret I would use to store the account key.

952
01:21:41,200 --> 01:21:43,120
But again, I really don't want to use it.

953
01:21:43,280 --> 01:21:44,960
We can disable their use.

954
01:21:45,440 --> 01:22:07,840
So, here I notice I had this rotation reminder option that I could set up, but if I go and look at the configuration of my account, one of the nice things I could do here is I could actually disable it, so I could disable the storage account key access, so no storage account keys cannot be used.

955
01:22:08,720 --> 01:22:16,640
Now that has some other implications about shared access signatures, which we will talk about, but realize I can absolutely do that.

956
01:22:17,200 --> 01:22:22,640
I guess while we're in here, there's also this anonymous BLOB access.

957
01:22:24,080 --> 01:22:30,880
So one of the things I could also do here is say, hey, I don't want to enable this read anonymous access to my BLOB storage account.

958
01:22:31,520 --> 01:22:33,040
Now you might say, well, what's the harm in that?

959
01:22:33,040 --> 01:22:34,080
It's only reading.

960
01:22:34,520 --> 01:22:37,200
But realize even a read is an operation.

961
01:22:37,200 --> 01:22:42,560
So if someone spammed my storage account just reading the data, it would cost me money.

962
01:22:43,360 --> 01:22:46,480
So I can block this being possible.

963
01:22:46,720 --> 01:23:02,160
If it's enabled like it is here, then at a storage container level, I can enable particular BLOB or actually list the contents of BLOBs in a container.

964
01:23:02,160 --> 01:23:04,080
So I can change the access level.

965
01:23:04,560 --> 01:23:05,440
Should I want to?

966
01:23:06,560 --> 01:23:08,680
But generally we like the no anonymous access.

967
01:23:09,120 --> 01:23:16,720
And once again, from a configuration perspective, and I can even then use Azure Policy to enforce, I probably just don't want that there at all.

968
01:23:19,280 --> 01:23:21,600
So we have the access keys, don't want to use them.

969
01:23:23,120 --> 01:23:30,080
The better option is Entra ID integration for the data plane role-based access control.

970
01:23:31,080 --> 01:23:33,920
And that's really available now for pretty much all of them.

971
01:23:33,920 --> 01:23:35,480
BLOB, queue, table, files.

972
01:23:35,480 --> 01:23:37,520
Remember, I can integrate with Kerberos.

973
01:23:38,160 --> 01:23:42,800
For BLOB, I can even add those additional conditions that we talked about when we did the identity module.

974
01:23:43,280 --> 01:23:47,920
So this is a much better option because then I can be a lot more granular around those permissions.

975
01:23:49,440 --> 01:23:57,200
So if I was, for example, I mean right here, if I'm looking at images and access control, I could set a role assignment

976
01:23:57,760 --> 01:24:05,280
Specific to this particular container, and if we look at the roles, let's just do BLOB data.

977
01:24:05,280 --> 01:24:12,520
All right, BLOB data owner, BLOB data contributor, BLOB data reader.

978
01:24:13,120 --> 01:24:18,800
I would see the same for queue, I would see the same for table.

979
01:24:21,400 --> 01:24:32,080
And the key point here is we talked about previously on these roles, let's say BLOB data reader, and I view the role, we have these actions, but remember that's the Azure control plane.

980
01:24:32,640 --> 01:24:35,600
But then we have these data actions.

981
01:24:36,240 --> 01:24:37,520
These are data plane.

982
01:24:37,840 --> 01:24:41,680
So this has the read BLOB permission on the data plane.

983
01:24:41,920 --> 01:24:49,040
So now if I go and look and I'm authenticating with an actual entry ID, which is what I'm doing here.

984
01:24:50,400 --> 01:24:52,760
I've authenticated with my Microsoft Entra user account.

985
01:24:52,760 --> 01:24:54,960
I'm not using the access key.

986
01:24:55,760 --> 01:25:02,560
So my permission is now based on that Entra integrated authentication to what I can or can't see.

987
01:25:02,560 --> 01:25:03,840
So now it's based on those.

988
01:25:04,080 --> 01:25:06,320
So this is a much better option.

989
01:25:07,280 --> 01:25:15,120
And the other nice thing, remember, if I'm using things like managed identities, well, managed identity is an Entra identity.

990
01:25:15,280 --> 01:25:19,440
So imagine I had a computer service that wanted to go and talk to a storage account.

991
01:25:19,920 --> 01:25:28,880
now I can just use the managed identity of the compute service and give it data plane permissions for BLOB or queue or table, it would now be able to use those things.

992
01:25:30,080 --> 01:25:48,400
And so when I think about the different types of service for a second, so for my BLOB queue table, one of the awesome things here is entra ID

993
01:25:48,960 --> 01:25:52,880
integrated role-based access control on the data plane.

994
01:25:52,880 --> 01:26:00,240
If I have this option, and this is available in a lot of the database offerings as well, I want to do this instead.

995
01:26:00,320 --> 01:26:01,480
This is the better option.

996
01:26:01,480 --> 01:26:05,200
And remember for Azure Files, we talked about this before.

997
01:26:05,760 --> 01:26:13,920
Azure Files, it likes Kerberos, and we can use our Active Directory domain services.

998
01:26:14,320 --> 01:26:17,440
We can use the Entra Kerberos service.

999
01:26:17,800 --> 01:26:23,360
If I don't have any active directory at all, we can use the Entra managed domain services.

1000
01:26:23,600 --> 01:26:28,600
So different options, and I'm still there not using the nasty all-powerful account key.

1001
01:26:28,600 --> 01:26:30,360
I've got other options on that.

1002
01:26:32,000 --> 01:26:42,640
Now additionally, if the all-powerful account key is too all-powerful, we can create shared access signatures.

1003
01:26:43,040 --> 01:26:45,440
So think of this as a more granular

1004
01:26:45,920 --> 01:26:48,240
set of permissions on a smaller scope.

1005
01:26:49,600 --> 01:26:51,040
Now one thing we can do is account.

1006
01:26:51,200 --> 01:26:57,840
So an account shared access signature is ad hoc in that there's no policy that drives the configuration.

1007
01:26:58,000 --> 01:27:00,160
I just have to set the things I want.

1008
01:27:00,880 --> 01:27:03,680
And when I'm using an account, it's at the account level.

1009
01:27:04,000 --> 01:27:07,360
So it could be for any of the types of service that exists in the account.

1010
01:27:08,800 --> 01:27:11,360
Then there's service shared access signature.

1011
01:27:12,400 --> 01:27:17,360
This is against a specific storage account service like BLOB or queue or table.

1012
01:27:18,400 --> 01:27:29,880
And that has the ability to also be based on some policy, which then if I update the policy while I've already issued this signature, it would then get updated.

1013
01:27:29,880 --> 01:27:31,520
So I've got some flexibility there.

1014
01:27:32,080 --> 01:27:38,640
So when I think of these options, so I can also create these shared access signatures.

1015
01:27:40,000 --> 01:27:45,840
and I can do it at the account level, or I can do it at a service level.

1016
01:27:46,880 --> 01:27:56,560
These account has to be ad hoc, service can be ad hoc, or service can be based on some policy that I could then update.

1017
01:27:57,120 --> 01:28:08,240
Key point though, these shared access signatures are signed by one of the account keys.

1018
01:28:10,160 --> 01:28:13,680
So if I disable the account keys, I can't use shared access signatures.

1019
01:28:15,680 --> 01:28:27,520
If I was to rotate the account key, it will break that shared access signature, which is in a way I can kind of revoke the thing because it's been signed and validated by that.

1020
01:28:28,080 --> 01:28:31,680
So that's a good thing to understand from those perspectives.

1021
01:28:32,880 --> 01:28:34,240
So let's have a quick look at these.

1022
01:28:38,880 --> 01:28:45,840
So if I go to the storage account level for a second, I see my shared access signatures.

1023
01:28:48,160 --> 01:28:52,000
And notice here I'm just creating one.

1024
01:28:52,160 --> 01:29:02,400
I'm picking, because it's the account level, I can pick whatever services I want, the types of resource, the permissions I want, start and expiry times, which IPs can use it.

1025
01:29:03,520 --> 01:29:08,560
how it's going to be routed, which key it's going to use to sign it, which is the one I would have to rotate if I wanted to kill it.

1026
01:29:09,440 --> 01:29:19,280
And then once I've done all those various things, I would just say generate it and it will give me that shared access signature that then when I used it, would be good to go.

1027
01:29:20,560 --> 01:29:22,080
I would then have that ability.

1028
01:29:22,960 --> 01:29:30,960
If I go to a particular service, so let's say I go to a particular container, now

1029
01:29:32,080 --> 01:29:33,840
I have shared access tokens.

1030
01:29:34,960 --> 01:29:38,640
So user delegation key is when I hook into things like Entra for delegated access.

1031
01:29:38,640 --> 01:29:41,040
But once again, I'm going to sign by a certain key.

1032
01:29:42,240 --> 01:29:59,960
It's permissions now on this particular container, but I could base it on a policy, and I can create additional policies for the various configurations I want, and I could change the policy later on to change what that given out signature actually means.

1033
01:30:01,680 --> 01:30:13,600
But same start, expiry IP ranges, I can then go and create the particular token and it would then be usable for whatever this period of time was.

1034
01:30:13,840 --> 01:30:16,400
So if I generate this just in this, there's the URL.

1035
01:30:17,040 --> 01:30:22,000
So just by using this URL, I would then go and have that access.

1036
01:30:22,000 --> 01:30:29,040
So you can see it's got, if we scroll, look here, you can see the URL is obviously the particular service.

1037
01:30:29,440 --> 01:30:33,920
then the particular container, and then it's going to have the details.

1038
01:30:33,920 --> 01:30:39,440
You scroll over the actual signature, which is all of the control part I care about.

1039
01:30:40,480 --> 01:30:54,000
And because it's key one, if suddenly I wanted to revoke this and it wasn't based on a policy, if I just go to my keys and just rotate key one, that shared access signature is now useless.

1040
01:30:54,560 --> 01:30:57,680
It's been rendered because I've done that rotation.

1041
01:30:58,320 --> 01:31:01,440
So just realize I can very easily do those things.

1042
01:31:03,120 --> 01:31:11,040
Now, very commonly, if I'm using the ad hoc, remember I can't revoke it unless I want to go and rotate the key.

1043
01:31:11,040 --> 01:31:17,200
I tend to keep it very short-lived, same as we do with access tokens in Entra, because they're hard to revoke.

1044
01:31:18,400 --> 01:31:25,600
A common architecture, if I actually do want to use a shared access signature, is I have something called a valet key pattern.

1045
01:31:26,400 --> 01:31:38,880
Some other process would go and create the shared access signature, put it, for example, in a secret in an Azure Key Vault, give the process permission to that secret, and then it will use that access point.

1046
01:31:38,880 --> 01:31:42,720
And then there's some process that will go and update it periodically.

1047
01:31:42,720 --> 01:31:50,000
Or saying, it has to go and request, hey, I need this permission, rather than giving some process direct ability to create those signatures.

1048
01:31:50,000 --> 01:31:52,160
There's a number of different things we can do to use them.

1049
01:31:52,480 --> 01:31:55,600
But I would really, really stress, I mean, things have changed A lot.

1050
01:31:56,240 --> 01:32:03,840
If you can, just don't use them, like use the data plain role-based access control it's just such a better option.

1051
01:32:06,480 --> 01:32:15,120
So, assign an account key cannot easily revoke without regenerating the account key, as we talked about, so don't panic.

1052
01:32:15,120 --> 01:32:17,920
Just one thing when I showed you that shared access signature.

1053
01:32:19,200 --> 01:32:23,760
You may be looking at that and going like, my God, this is sent plain text over the internet.

1054
01:32:24,320 --> 01:32:30,560
Anyone could grab that and then they'd be able to see my signature and all my privacy is over.

1055
01:32:31,120 --> 01:32:33,680
That's not how TLS works.

1056
01:32:34,480 --> 01:32:36,880
Remember that was sent over https://.

1057
01:32:37,440 --> 01:32:45,200
In reality, the way these things really work, if I have a shared access signature, if I fought for a second, I've got some computer.

1058
01:32:46,400 --> 01:32:56,080
and imagine I actually have my storage account for a second, and I had that full URL, but that's not the way, I'm not talking to the full URL.

1059
01:32:56,480 --> 01:33:05,200
My client firstly makes a request to DNS to work out what is the IP address of the storage account, just the storage account, the host name.

1060
01:33:05,760 --> 01:33:12,160
It then establishes A TCP session with the IP address,

1061
01:33:13,960 --> 01:33:18,560
and then it establishes A TLS session still with the IP address.

1062
01:33:18,560 --> 01:33:20,720
It has not sent the URL yet.

1063
01:33:20,720 --> 01:33:22,560
All it's still talking about is to the IP address.

1064
01:33:22,960 --> 01:33:33,920
Once it establishes the TLS session, then over that nice encrypted session, that's where it then sends the actual URL, which has the signature.

1065
01:33:34,080 --> 01:33:35,680
So it's sent over TLS encryption.

1066
01:33:35,680 --> 01:33:39,120
So it's never sent plain text over the internet.

1067
01:33:40,000 --> 01:33:40,960
It's always encrypted.

1068
01:33:41,040 --> 01:33:41,840
So just if that

1069
01:33:42,240 --> 01:33:43,840
that helps in any way.

1070
01:33:44,560 --> 01:33:45,760
I still don't want to use them.

1071
01:33:46,560 --> 01:33:54,960
I'd still rather use a data plane, role-based access control, but it is not being sent plain text over the internet, which I think sometimes people get confused about.

1072
01:33:55,760 --> 01:33:58,920
That's not the reality at all.

1073
01:33:59,000 --> 01:34:00,000
Okay, so we're not panicking.

1074
01:34:01,440 --> 01:34:02,160
Encryption.

1075
01:34:04,480 --> 01:34:05,680
It's always encrypted at rest.

1076
01:34:06,240 --> 01:34:10,080
There's no option to not have your data encrypted.

1077
01:34:10,320 --> 01:34:10,800
Now, when I

1078
01:34:11,280 --> 01:34:13,600
create my storage account, I can do a double encryption.

1079
01:34:14,320 --> 01:34:17,920
And then it also uses some infrastructure level encryption.

1080
01:34:18,240 --> 01:34:24,200
But just anyway, normally it's a 256-bit AES, which is FIPS 140-2 compliant.

1081
01:34:24,680 --> 01:34:35,440
And the infrastructure just adds another level of encryption, which uses a different encryption algorithm, a different key, and I can go and configure this in the storage account.

1082
01:34:35,600 --> 01:34:37,360
So if we actually jumped over for a second.

1083
01:34:38,720 --> 01:34:53,600
If I'm in my security and networking, I look at my encryption, you can see my infrastructure encryption is disabled, but that would add a second layer, but it's only when I create the storage account.

1084
01:34:54,000 --> 01:34:58,960
So, if I was creating my storage account, so actually encryption...

1085
01:34:59,800 --> 01:35:03,600
At this point, I can pick Microsoft managed or customer managed.

1086
01:35:03,600 --> 01:35:07,760
Customer managed, remember, is where the key lives within my key vault.

1087
01:35:07,760 --> 01:35:10,640
So I'm responsible for its rotation and everything else.

1088
01:35:11,040 --> 01:35:17,120
But then I could also turn on infrastructure encryption that would just add another level of encryption.

1089
01:35:17,120 --> 01:35:19,280
But that is always a Microsoft managed key.

1090
01:35:19,760 --> 01:35:22,160
So that lets me just double encrypt the storage.

1091
01:35:22,640 --> 01:35:25,440
So that is there and available.

1092
01:35:26,000 --> 01:35:28,320
But remember, when I'm looking at this encryption key,

1093
01:35:30,000 --> 01:35:32,560
Right now mine is Microsoft managed, but I can change it.

1094
01:35:32,960 --> 01:35:43,600
I can change it to a customer managed, and then it's just going to be a key in my key vault, and I would just have to set the appropriate permissions so it can go and access that.

1095
01:35:44,160 --> 01:35:46,160
So I can choose my own key in my own key vault.

1096
01:35:46,480 --> 01:35:49,400
I can even have that key in a different tenant.

1097
01:35:50,800 --> 01:35:55,600
So imagine a scenario maybe where I'm hosting some services for a customer,

1098
01:35:56,400 --> 01:36:01,880
This would let the customer have the key in their key vault so they could revoke it if they wanted to.

1099
01:36:01,880 --> 01:36:04,240
And I'm going to use that to encrypt the storage account.

1100
01:36:04,320 --> 01:36:10,560
So in a software as a service type scenario, that would be a nice option to let the customer keep the key.

1101
01:36:10,680 --> 01:36:15,200
And of course, if it's customer managed key, then I get to pick how often I rotate it.

1102
01:36:15,360 --> 01:36:19,680
If I want to just revoke that thing, I have a lot more control over it.

1103
01:36:20,400 --> 01:36:23,760
By default, a customer managed key does not apply to queue and table.

1104
01:36:24,000 --> 01:36:25,520
It will to BLOB and files.

1105
01:36:26,400 --> 01:36:32,960
If I want it for queue and table, I set that at the account creation time to say, hey, I want to use my own key.

1106
01:36:33,840 --> 01:36:37,280
Now this encryption key is for the entire account.

1107
01:36:37,760 --> 01:36:43,200
But again, that SaaS solution, maybe I've got different customers in the same storage account.

1108
01:36:44,480 --> 01:36:45,920
I can use encryption scopes.

1109
01:36:46,000 --> 01:36:51,040
So encryption scopes let me have different sets of configuration for encryption.

1110
01:36:51,720 --> 01:36:54,960
And then when I create a container or even upload a specific BLOB,

1111
01:36:55,520 --> 01:36:58,400
I can say, actually use this encryption scope.

1112
01:36:58,560 --> 01:37:01,120
So I could have a different, maybe it's a different Microsoft managed key.

1113
01:37:01,120 --> 01:37:02,480
I just want different keys.

1114
01:37:02,880 --> 01:37:06,960
Or it could be different customer managed keys as part of that.

1115
01:37:07,520 --> 01:37:12,240
So it's not just one big key for all of those different sets of capabilities.

1116
01:37:12,800 --> 01:37:19,120
So if we jumped and had a look at this, so if I'm looking at my encryption, notice I have encryption scopes.

1117
01:37:19,760 --> 01:37:21,840
So I've got a different scope.

1118
01:37:22,640 --> 01:37:25,680
that I'm just using a Microsoft Managed Key, but it would be a different key.

1119
01:37:26,160 --> 01:37:32,720
I could add another encryption scope, and I could pick to use Custom Managed Key, and I want infrastructure encryption.

1120
01:37:33,600 --> 01:37:48,320
So then, when I was to go ahead and let's say create a new container as part of my advanced settings, I can say I don't want this to use the regular encryption, I want it to use this encryption scope, so I want it to use a different key.

1121
01:37:49,360 --> 01:37:49,840
Or...

1122
01:37:51,680 --> 01:37:56,960
I could even, at a BLOB level, I want to upload a new BLOB, advanced.

1123
01:37:57,760 --> 01:38:03,120
I want to use a different encryption scope.

1124
01:38:03,600 --> 01:38:07,600
So A BLOB level at time of upload, I could encrypt a particular BLOB.

1125
01:38:08,080 --> 01:38:18,560
So again, this is just really useful, where, hey, maybe it's one storage account, but at a container level, or maybe even individual BLOBs, I have some separation.

1126
01:38:19,040 --> 01:38:24,880
between the needs for encryption, and I can absolutely do that with this ability.

1127
01:38:25,360 --> 01:38:28,320
So that's a pretty nice feature there.

1128
01:38:30,320 --> 01:38:33,480
Encryption in transit can be enforced at the storage account level.

1129
01:38:33,480 --> 01:38:34,720
So it's always encrypted at rest.

1130
01:38:35,920 --> 01:38:37,200
I can do double encryption.

1131
01:38:37,280 --> 01:38:40,320
I can do different keys depending on if I want it.

1132
01:38:40,320 --> 01:38:43,600
Encryption in transit, I need to be using TLS.

1133
01:38:43,840 --> 01:38:46,240
So as part of the configuration of the storage account,

1134
01:38:47,920 --> 01:38:48,960
I can enforce that.

1135
01:38:49,200 --> 01:39:00,400
So if I go back to my storage account and I go to my configuration, one of my options here, secure transfer required.

1136
01:39:00,880 --> 01:39:04,240
So that would require TLS when I'm talking through the APIs.

1137
01:39:04,240 --> 01:39:08,720
It would require SMB3 if I'm using Azure files.

1138
01:39:08,720 --> 01:39:14,160
So it gives me that ability to control the encryption there as well.

1139
01:39:16,400 --> 01:39:17,120
Networking.

1140
01:39:17,920 --> 01:39:24,080
Nearly every Azure resource that's providing some service has a native firewall capability to it.

1141
01:39:24,640 --> 01:39:26,600
And storage accounts are no exception to this.

1142
01:39:26,600 --> 01:39:37,680
So standard features like private endpoints, service endpoints, IP-based firewalls are all available as part of my storage account.

1143
01:39:38,840 --> 01:39:45,200
And the way this works, if you've never seen these things, so imagine, okay, let's say we have

1144
01:39:46,640 --> 01:39:47,760
our particular storage account.

1145
01:39:48,240 --> 01:39:50,000
So this is storage account one.

1146
01:39:52,800 --> 01:39:58,000
And it has its own little built-in firewall sitting in front of it.

1147
01:39:59,080 --> 01:40:02,000
And now imagine I have my virtual network.

1148
01:40:03,440 --> 01:40:07,280
Now remember, your virtual network is a private IP space.

1149
01:40:07,840 --> 01:40:10,320
It is not internet routable.

1150
01:40:11,520 --> 01:40:14,880
And so while in the firewall, I can do IP-based rules.

1151
01:40:15,680 --> 01:40:21,200
That's not useful for the IP space inside of VNet because it's this private, non-routable IP space.

1152
01:40:21,760 --> 01:40:30,320
So the first thing we can do, imagine I have a subnet, one, and a subnet is just a portion of the IP space.

1153
01:40:31,200 --> 01:40:33,600
I can enable service endpoints.

1154
01:40:33,600 --> 01:40:36,160
Actually, I'm going to do it on the second subnet.

1155
01:40:36,320 --> 01:40:43,520
So subnet 2, I'm going to say, hey, I'm going to add service endpoint for storage.

1156
01:40:44,120 --> 01:40:49,360
And I have the flexibility to say, and this is any storage service, maybe just within a certain region.

1157
01:40:49,960 --> 01:40:52,320
And what this does, it actually does two things.

1158
01:40:53,120 --> 01:41:02,560
It gives me a more optimal routing path between the things in, there's only stuff in this subnet to the storage account.

1159
01:41:03,040 --> 01:41:10,880
But now this particular subnet becomes a known entity to storage accounts either within the region or globally.

1160
01:41:11,120 --> 01:41:12,480
Imagine this is called VNet1.

1161
01:41:13,280 --> 01:41:27,600
So what this is now going to let me do is I can now say, well, actually, VNet 1, subnet 1, oh no, subnet 2, subnet 2 is allowed.

1162
01:41:28,120 --> 01:41:32,080
Because I added a service endpoint, so I can now add it to the configuration of it.

1163
01:41:32,720 --> 01:41:40,320
So now anything within here would be allowed to talk to the storage account, but things in other subnets, other networks would be blocked by its firewall.

1164
01:41:41,200 --> 01:41:43,840
The other thing I have is something called private endpoints.

1165
01:41:45,040 --> 01:41:57,520
So, a private endpoint is an IP address, so I create a private endpoint, private endpoint one, and it is configured to talk to a specific instance of a service.

1166
01:41:58,320 --> 01:42:01,360
So, in this case, I added a private endpoint for storage account one.

1167
01:42:02,560 --> 01:42:04,400
Now, this is just an IP address.

1168
01:42:04,960 --> 01:42:08,960
So the difference now is that anything in this subnet can talk to the storage account.

1169
01:42:09,200 --> 01:42:12,880
Anything that can resolve this IP address can talk to it.

1170
01:42:13,040 --> 01:42:14,480
So it could be other things in the VNet.

1171
01:42:14,880 --> 01:42:25,200
If I had VNet peering, if I had a express route, if I had a site-to-site VPN, if it can talk to PE1 and there's a special DNS name I need, I'm going to talk about this in the networking module.

1172
01:42:25,200 --> 01:42:31,680
As long as I can resolve it correctly so I can do the certificates required for the encryption,

1173
01:42:32,120 --> 01:42:34,160
I'll be able to go and talk to this storage account service.

1174
01:42:34,400 --> 01:42:36,960
So that's a really great capability as well.

1175
01:42:38,640 --> 01:42:42,320
But there's something else we can do.

1176
01:42:42,320 --> 01:42:45,720
So we have something called resource instance rules.

1177
01:42:45,720 --> 01:43:00,080
And what that lets me do is that, again, my storage account level, I can say I only want to enable a specific instance of a supported resource be allowed to talk to me.

1178
01:43:01,400 --> 01:43:14,640
And so now what I can do is if I think of this picture again, as part of the firewall, as part of my resource instance rules, I could say something like, well, I only, maybe I've got a SQL database.

1179
01:43:15,760 --> 01:43:17,840
So I've got SQL one.

1180
01:43:18,960 --> 01:43:22,320
Maybe it's using storage as a backup mechanism.

1181
01:43:22,880 --> 01:43:29,680
So I want SQL one to be allowed to talk to this storage account.

1182
01:43:29,680 --> 01:43:30,880
So I can say, hey,

1183
01:43:31,440 --> 01:43:34,000
SQL 1 is allowed.

1184
01:43:35,280 --> 01:43:37,440
So that's a resource instance rule.

1185
01:43:38,080 --> 01:43:39,040
Now I didn't mention it.

1186
01:43:39,280 --> 01:43:42,320
I should have done service endpoints also have service endpoint policies.

1187
01:43:42,800 --> 01:43:45,920
Now that's not really a security feature of the storage account.

1188
01:43:46,640 --> 01:43:53,400
But imagine I had some bad actor, a bad person, trying to copy data to a rogue storage account.

1189
01:43:54,000 --> 01:43:59,760
a service endpoint policy is saying I configure on the subnet that says you're only allowed to talk to storage account one.

1190
01:44:00,000 --> 01:44:04,280
You can't talk to storage account two, so you can't go and copy the software to somewhere you shouldn't.

1191
01:44:04,280 --> 01:44:15,040
So again, not really a storage account feature, but it's a way to stop data exfiltration by someone copying data to a point they shouldn't copy it to.

1192
01:44:15,680 --> 01:44:21,520
But yeah, the resource instance rules, it's just part of the network configuration.

1193
01:44:21,760 --> 01:44:22,880
So go to networking.

1194
01:44:24,400 --> 01:44:34,080
and I was to enable from specific networks, I can just pick that particular resource type and then I'd be able to pick a particular instance of it.

1195
01:44:34,960 --> 01:44:38,160
So a really nice way to lock that down.

1196
01:44:39,520 --> 01:44:46,160
Okay, so we have all those regular networking things we can do.

1197
01:44:47,280 --> 01:44:48,920
Then we get to lifecycle management.

1198
01:44:49,200 --> 01:44:53,760
Now, over time, we're going to amass massive amounts of data, especially in those data lakes.

1199
01:44:54,320 --> 01:44:57,600
And that could be that raw data from many systems.

1200
01:44:57,720 --> 01:44:59,120
And we pay for that.

1201
01:44:59,760 --> 01:45:01,680
We talked about the access tiers.

1202
01:45:02,000 --> 01:45:05,440
Now, those access tiers are super useful to optimize my cost.

1203
01:45:05,760 --> 01:45:07,120
I'll pay less for the capacity.

1204
01:45:07,120 --> 01:45:08,480
I pay more for the interactions.

1205
01:45:09,120 --> 01:45:13,680
But that's a lot of work to manually go and move files between the tiers.

1206
01:45:14,880 --> 01:45:16,000
Most likely,

1207
01:45:16,640 --> 01:45:18,320
based on a certain amount of time.

1208
01:45:18,480 --> 01:45:32,480
Maybe it's the time it was created, maybe it's the time it was last modified, maybe it's the time it was last accessed, which means if I want to do access, I have to enable access tracking, but X number of days, move it, move it down a tier.

1209
01:45:32,880 --> 01:45:34,640
Now remember, premium doesn't have any tiers.

1210
01:45:34,880 --> 01:45:37,360
I could just delete it after a certain number of days.

1211
01:45:38,160 --> 01:45:42,080
Append blobs don't have tiering, so I would only be able to delete it.

1212
01:45:42,080 --> 01:45:45,280
So lifecycle management is a capability to automate

1213
01:45:46,400 --> 01:45:51,760
some of the things we can do, but it can only do the things that the type of object is capable of.

1214
01:45:51,760 --> 01:45:54,320
So I can't do tiering if something doesn't support tiering.

1215
01:45:54,960 --> 01:46:05,800
But the whole goal here is lifecycle management enables rules to be defined that will automatically do things to the data.

1216
01:46:06,080 --> 01:46:09,520
So move it between tiers, delete it after a period of time.

1217
01:46:09,760 --> 01:46:14,720
I can use filters to limit based on the name to only do certain stuff.

1218
01:46:15,120 --> 01:46:19,280
And those checks can be based on the creation, the modified, the access date.

1219
01:46:19,760 --> 01:46:25,280
And what this would let me do, if I think of wherever we had tiers, I don't remember where that is anymore.

1220
01:46:25,840 --> 01:46:26,560
Up tier, there we go.

1221
01:46:27,280 --> 01:46:33,800
So the nice thing I can do right here is I can do lifecycle management.

1222
01:46:38,240 --> 01:46:39,920
So I'm going to create these rules.

1223
01:46:41,040 --> 01:46:53,200
And I could say, remember with premium, all I could do is to say, well, after X days, I could put it in the trash.

1224
01:46:53,440 --> 01:46:54,640
That's trash, not a crown.

1225
01:46:55,120 --> 01:46:56,720
So X days, move it to trash.

1226
01:46:57,840 --> 01:47:02,960
But here I could say, well, after 15 days, move it to cool.

1227
01:47:04,440 --> 01:47:09,920
After 30 days, well, let's say 45 days,

1228
01:47:10,520 --> 01:47:11,520
I'll move it to cult.

1229
01:47:12,800 --> 01:47:19,720
Maybe after, I don't know, 90 days, I'll move it to archive.

1230
01:47:19,720 --> 01:47:30,080
And then maybe after 180 days, maybe after a year, so 365 days, I'm going to go and put it to the trash.

1231
01:47:30,640 --> 01:47:34,880
So I could automate those things with life cycle management.

1232
01:47:36,240 --> 01:47:36,560
And

1233
01:47:37,360 --> 01:47:38,640
This is just part of the storage account.

1234
01:47:38,640 --> 01:47:41,360
So it's in the storage account I'm defining these things.

1235
01:47:41,440 --> 01:47:53,600
So if we go and look, I could go to my lifecycle management and I just create a certain rule.

1236
01:47:54,240 --> 01:47:57,360
So in this case, I think I've got to move data for access tiers.

1237
01:47:58,880 --> 01:48:01,360
And you can see what am I applying it to.

1238
01:48:02,400 --> 01:48:06,320
I could apply different filters and I've just got a series of rules.

1239
01:48:06,800 --> 01:48:09,200
Hey, if it's not been accessed for 15 days, move it to call.

1240
01:48:10,320 --> 01:48:12,960
Not been accessed for 45, move it to cold.

1241
01:48:13,360 --> 01:48:15,920
Not been accessed for 135, move it to archive.

1242
01:48:16,560 --> 01:48:20,240
I don't have any deletion once, but I could totally do that.

1243
01:48:20,480 --> 01:48:26,320
So I could add a condition based on modified created access, then delete.

1244
01:48:26,640 --> 01:48:29,200
So I've already used up all of the other options up there.

1245
01:48:29,920 --> 01:48:33,680
So I can automate all of those various tasks I need to do.

1246
01:48:35,360 --> 01:48:36,400
for my storage account.

1247
01:48:36,960 --> 01:48:41,520
But it is within the storage account, you see I'm creating these various policies.

1248
01:48:44,960 --> 01:48:47,280
But now we have Azure Storage Actions.

1249
01:48:47,840 --> 01:48:49,760
This takes it a step beyond that.

1250
01:48:50,320 --> 01:48:57,280
It supports block, page, append for both the flat namespace and the hierarchical namespace, either data lake.

1251
01:48:57,840 --> 01:49:02,480
It has all of the same capabilities of lifecycle management and then some.

1252
01:49:02,960 --> 01:49:05,280
I can set immutability so you can't change it.

1253
01:49:05,280 --> 01:49:06,640
I can set BLOB tags.

1254
01:49:06,640 --> 01:49:07,600
I can undelete.

1255
01:49:07,680 --> 01:49:09,440
I can do a whole bunch of more stuff.

1256
01:49:10,000 --> 01:49:15,360
Same thing, if I try to use a feature that isn't supported for that type of BLOB, it's just not going to take effect.

1257
01:49:15,920 --> 01:49:18,240
I can have way more complex conditions.

1258
01:49:18,240 --> 01:49:20,160
So I can have group clauses.

1259
01:49:20,240 --> 01:49:24,320
I can have wild cards, both star for many characters, question mark for single characters.

1260
01:49:24,800 --> 01:49:28,080
The nice thing here is I'm going to essentially create the tasks.

1261
01:49:28,400 --> 01:49:46,000
So what I'm going to do here with this capability is instead of it just being this per storage account, what I'm now going to have is this ability to create these Azure storage actions.

1262
01:49:48,000 --> 01:49:50,800
And centrally, I'm going to create these tasks.

1263
01:49:52,560 --> 01:49:56,880
And a task is going to be compiled of a bunch of conditions

1264
01:49:58,960 --> 01:50:05,360
So that's these if something then do something, and then I'm going to assign it.

1265
01:50:07,840 --> 01:50:09,600
So I assign it to a storage account one.

1266
01:50:09,600 --> 01:50:12,000
I'm going to assign it to storage account two.

1267
01:50:12,520 --> 01:50:20,200
And the nice thing here is for those assignments, I can assign these things way beyond just, for example, the sub.

1268
01:50:20,200 --> 01:50:21,840
As long as it's the same tenant,

1269
01:50:22,360 --> 01:50:24,640
I'm going to be able to leverage and use that thing.

1270
01:50:24,640 --> 01:50:26,960
So that's a really powerful capability.

1271
01:50:27,520 --> 01:50:47,440
Now, the way this works is, I guess actually quickly, while I'm in this storage account, if I look at my access control for a second, I look at my role assignments and just search for image, you'll notice I have an image task that I gave storage BLOB data owner permission to.

1272
01:50:47,760 --> 01:50:49,840
So this image task thing.

1273
01:50:52,000 --> 01:50:58,000
If I now go and look at my storage account actions, I created one called image task.

1274
01:50:58,000 --> 01:50:59,600
So it has its own identity.

1275
01:51:01,520 --> 01:51:02,680
I have to give it permissions.

1276
01:51:02,680 --> 01:51:08,960
So for any storage account I want it to be able to do stuff on, it has to have data plain role-based access control.

1277
01:51:09,680 --> 01:51:14,880
But then once I've done that, I define the conditions.

1278
01:51:15,120 --> 01:51:21,040
So here I'm looking at the BLOB name ending with a certain thing, but it could start with, it's empty, it equals, it matches.

1279
01:51:21,600 --> 01:51:28,160
creation time, there's a whole sets of cool new clauses I can do.

1280
01:51:28,320 --> 01:51:31,360
Look at these, all these different actions and things I can look at.

1281
01:51:32,240 --> 01:51:35,920
And then I can do many different types of things.

1282
01:51:36,320 --> 01:51:45,120
Yes, I can set tiers, but I can do legal holds, set immutability policies, I could undelete the thing, lots of capabilities.

1283
01:51:45,600 --> 01:51:49,520
So this much richer set of options, and then I sign it.

1284
01:51:51,200 --> 01:51:55,320
And I can assign it basically anywhere I want within the same tenant.

1285
01:51:55,920 --> 01:51:58,280
So as long as it's the same tenant, I can do this.

1286
01:51:58,280 --> 01:52:06,080
So it's this much better capability to now perform things at large scale.

1287
01:52:06,720 --> 01:52:09,640
And I pay for the storage task, at least I will when it's GA.

1288
01:52:09,640 --> 01:52:13,520
But if you think about the money, it may save me by essentially managing those things.

1289
01:52:13,840 --> 01:52:16,480
That's a pretty huge capability.

1290
01:52:18,520 --> 01:52:22,480
Okay, so what are some of the protection capabilities we have?

1291
01:52:23,440 --> 01:52:25,200
Now, the first one is snapshots.

1292
01:52:26,560 --> 01:52:31,720
And the whole point about snapshots is it's a point in time view of the BLOB or files share.

1293
01:52:31,840 --> 01:52:32,960
It's read-only.

1294
01:52:33,760 --> 01:52:35,200
It's only incremental storage.

1295
01:52:35,200 --> 01:52:40,880
So I'm only going to pay for the changes to the data, not the entire content.

1296
01:52:41,520 --> 01:52:47,800
But I've drawn it in gray because it's basically been killed off by a better feature.

1297
01:52:48,960 --> 01:52:53,760
So we're going to combine a number of different features to get a better set of capabilities.

1298
01:52:54,320 --> 01:52:56,560
Now firstly, BLOB versioning.

1299
01:52:57,120 --> 01:52:58,960
Remember we talked about what is a BLOB?

1300
01:52:59,680 --> 01:53:05,680
And A BLOB is really nothing more than a set of blocks that are chained together.

1301
01:53:06,080 --> 01:53:08,480
So if we talk about where we talked about, what do we talk about blocks?

1302
01:53:08,840 --> 01:53:13,600
Okay, so what is a block BLOB?

1303
01:53:13,600 --> 01:53:17,600
A block BLOB is we have a certain version.

1304
01:53:18,240 --> 01:53:21,760
So it's this block, and these blocks can be different sizes.

1305
01:53:22,240 --> 01:53:24,400
It's these blocks chained together.

1306
01:53:25,600 --> 01:53:25,920
Great.

1307
01:53:27,200 --> 01:53:29,680
Then I change something about this block BLOB.

1308
01:53:30,320 --> 01:53:31,440
I change one block.

1309
01:53:32,240 --> 01:53:38,560
So now I change this middle one to have some slightly different content.

1310
01:53:38,960 --> 01:53:44,640
So now the chain is this of the blocks.

1311
01:53:45,520 --> 01:53:47,920
But what the versioning capability does

1312
01:53:48,160 --> 01:53:51,360
is it's like, well, this was the V1 version.

1313
01:53:51,360 --> 01:53:52,560
This is the V2.

1314
01:53:52,880 --> 01:53:54,720
So this is V1.

1315
01:53:55,120 --> 01:53:58,720
These blocks are my V2 version of it.

1316
01:53:59,440 --> 01:54:01,920
So I now get version capabilities.

1317
01:54:02,840 --> 01:54:07,880
And once again, it's only storing the changed blocks, and the blocks can be of various sizes.

1318
01:54:07,880 --> 01:54:10,240
So it's just this chain of different blocks.

1319
01:54:10,880 --> 01:54:17,040
Now, it is the entire changed block, but hopefully, again, it can be different sizes around those capabilities.

1320
01:54:17,760 --> 01:54:23,800
And if we looked at the storage account, we can see we have all of these options available to us.

1321
01:54:23,800 --> 01:54:28,120
So I'll just jump over, go and look at my data management.

1322
01:54:30,160 --> 01:54:34,800
And if I look at my data protection, we'll see all these various options available.

1323
01:54:36,560 --> 01:54:44,800
So the key point here is I've got versioning enabled, and I've got this BLOB change feed thing enabled.

1324
01:54:45,200 --> 01:54:53,120
And I've also got this soft delete thing enabled for blobs and containers, which is then giving me this other thing over here.

1325
01:54:53,120 --> 01:54:56,040
So we've got a whole bunch of different things that we're talking about.

1326
01:54:56,040 --> 01:55:00,640
Now, obviously, with those versions of blobs, they're going to accrue over time.

1327
01:55:01,280 --> 01:55:04,360
So you might use that lifecycle management we talked about to clean those up.

1328
01:55:04,360 --> 01:55:06,720
Then we have the change feed.

1329
01:55:06,960 --> 01:55:12,560
So the change feed, exactly as the name suggests, is really just a log of the changes.

1330
01:55:16,960 --> 01:55:27,840
So just think of it as, hey, as I made these changes, it made, there's a log of all the changes we're actually making as part of our environment.

1331
01:55:28,720 --> 01:55:31,440
So it's using a special append BLOB.

1332
01:55:31,440 --> 01:55:33,360
You'll see this dollar BLOB change feed.

1333
01:55:33,360 --> 01:55:35,520
It's doing the Apache Avro format.

1334
01:55:36,320 --> 01:55:38,640
I can pick it to delete after a certain amount of time.

1335
01:55:39,280 --> 01:55:41,600
But now I can track at any moment in time

1336
01:55:42,080 --> 01:55:43,520
when did the changes happen?

1337
01:55:43,920 --> 01:55:47,280
So now I've got all the versions and I know where it changed it.

1338
01:55:48,560 --> 01:55:52,000
Then the next feature we have is soft delete.

1339
01:55:53,280 --> 01:56:04,720
So soft delete is now saying, well, if I delete something, actually keep it.

1340
01:56:05,680 --> 01:56:09,440
So I want to keep it for X days.

1341
01:56:11,760 --> 01:56:14,560
And that could be at the BLOB level and the container level.

1342
01:56:14,560 --> 01:56:17,440
This could be between 1 and 365 days.

1343
01:56:17,600 --> 01:56:19,120
Now I am going to pay for this.

1344
01:56:20,480 --> 01:56:22,160
It's just, it's still having to store it.

1345
01:56:22,320 --> 01:56:25,200
So I'm going to store this for a certain amount of time.

1346
01:56:26,160 --> 01:56:28,000
But now I can undelete it.

1347
01:56:28,320 --> 01:56:33,360
If I have BLOB versioning, then I'll have a soft deleted version of the BLOB.

1348
01:56:33,680 --> 01:56:39,200
But again, I can still go back and I can see all those different capabilities within there.

1349
01:56:40,000 --> 01:56:41,280
So what that means,

1350
01:56:41,680 --> 01:56:46,880
is I now have a point in time restore, which is superior to snapshots.

1351
01:56:47,520 --> 01:56:48,800
Think about what we just drew.

1352
01:56:49,040 --> 01:57:04,960
So if I know all of the versions of something, I know when it happened, even if I delete something, I'm keeping it, all of those together, those 3 capabilities, give me point in time restore.

1353
01:57:05,680 --> 01:57:08,000
I don't have to create special snapshots.

1354
01:57:08,240 --> 01:57:12,320
I can just randomly pick any minute I can think of within the number of days.

1355
01:57:12,320 --> 01:57:19,840
Obviously, they're still at X days I'm doing this because this is a function of how long do I keep deleted things for?

1356
01:57:20,320 --> 01:57:23,200
How many versions of my kind of maybe pruning and cleaning things up?

1357
01:57:23,360 --> 01:57:24,560
How long is the change feed?

1358
01:57:24,560 --> 01:57:30,640
So there's, it can't be longer than any of these individual things.

1359
01:57:31,040 --> 01:57:34,560
But when I combine them together, I don't have to do snapshots now.

1360
01:57:34,960 --> 01:57:37,680
I can go back to any point in time I want.

1361
01:57:38,880 --> 01:57:42,320
And hey, fantastic set of capabilities there.

1362
01:57:46,880 --> 01:57:47,920
Azure File Sync.

1363
01:57:49,680 --> 01:57:53,440
So most of us are likely coming from Windows file shares.

1364
01:57:53,840 --> 01:57:56,880
So the good old SMB was running on our file server.

1365
01:57:57,760 --> 01:58:01,880
and I may have multiple file servers around my organization.

1366
01:58:01,880 --> 01:58:04,400
Now they're sync with distributed file system replication.

1367
01:58:04,640 --> 01:58:09,120
That's a feature of Windows to replicate between those different instances to keep them synchronized.

1368
01:58:09,120 --> 01:58:18,560
But I can also use Azure File Sync, which uses an Azure file share as a cloud endpoint as part of this thing called a sync group.

1369
01:58:19,600 --> 01:58:25,360
And then what I can have is up to 100 servers, like Windows file servers with a share.

1370
01:58:26,000 --> 01:58:28,240
that become part of that sync group.

1371
01:58:29,360 --> 01:58:32,400
There's an agent I install on the file service that registers.

1372
01:58:33,000 --> 01:58:37,840
And then once I've got this, it will replicate via that cloud endpoint.

1373
01:58:38,720 --> 01:58:46,480
So my order of operations, if I think about it, is well, I've probably already got my regular Windows servers with a file share on it.

1374
01:58:46,880 --> 01:58:47,840
I've got multiple of them.

1375
01:58:48,320 --> 01:58:50,080
I really want them to be kept in sync.

1376
01:58:51,280 --> 01:58:55,120
So I go and create a file share in Azure.

1377
01:58:55,360 --> 01:58:56,480
So this is in the cloud.

1378
01:58:59,360 --> 01:59:01,160
I then add the agent.

1379
01:59:01,680 --> 01:59:07,480
So there's a particular agent I add to this for the Azure File Sync.

1380
01:59:07,840 --> 01:59:08,800
So I'm adding the agent.

1381
01:59:08,960 --> 01:59:16,880
This now makes these show up as objects that the Azure File Sync Service knows about.

1382
01:59:17,840 --> 01:59:23,360
I'm then going to put those into a sync group.

1383
01:59:26,120 --> 01:59:29,600
And now what's going to happen is they will replicate via the file share.

1384
01:59:29,600 --> 01:59:31,600
Now these are not talking directly to each other.

1385
01:59:33,120 --> 01:59:43,920
They are replicating the data to here and both directions and there.

1386
01:59:44,480 --> 01:59:49,720
Now it is not designed to handle changes happening to all of these at the same time.

1387
01:59:49,720 --> 01:59:51,200
Like look at the all kit collisions.

1388
01:59:51,440 --> 01:59:57,680
Really, it's good if one of them is the primary one you're writing to, and then it can keep these synced to up to 100 servers.

1389
01:59:58,080 --> 01:59:59,960
Now, it's got...

1390
02:00:00,080 --> 02:00:01,600
all the ACLs in here as well.

1391
02:00:01,600 --> 02:00:12,800
So if I have integration with a Kerberos authentication, I can also then directly talk to this and I would have that constrained to what I have permissions to and access the data up here as well.

1392
02:00:12,800 --> 02:00:18,040
So it could also be the backup point I actually go and talk to should there be a problem.

1393
02:00:18,040 --> 02:00:21,760
And one of the nice things is these are probably a finite size.

1394
02:00:22,760 --> 02:00:24,560
There's a certain amount of storage they have.

1395
02:00:25,200 --> 02:00:28,160
So what I can also do is I can do cloud tiering.

1396
02:00:28,800 --> 02:00:33,840
So what this says is on these local servers, I can create a policy.

1397
02:00:34,480 --> 02:00:37,920
And what I could say here is, come on board, work.

1398
02:00:38,080 --> 02:00:38,480
Come on.

1399
02:00:39,680 --> 02:00:40,080
There we go.

1400
02:00:40,800 --> 02:00:44,400
I can add a policy to say, hey, I want to do tiering.

1401
02:00:46,880 --> 02:00:49,600
And that tiering could be based on a percentage of space.

1402
02:00:49,920 --> 02:00:53,120
So hey, once I'm down to 20% disk space left,

1403
02:00:53,600 --> 02:01:01,360
start tiering the least used things up to here, or it can also be based on X number of days or some combination.

1404
02:01:01,840 --> 02:01:11,040
It will still keep a thumbnail of the data, so I still see a shortcut to the data in the file share if I'm a client looking at it, but it's not stored here anymore.

1405
02:01:11,520 --> 02:01:17,600
If I actually tried to access the data, it would then pull it down from the file share and repopulate it into that.

1406
02:01:19,200 --> 02:01:22,320
One caveat, this is not even a caveat, something to think about though.

1407
02:01:22,800 --> 02:01:30,560
Windows has a nice USN journaling capability, so it makes it easy to know when something changes by that USN.

1408
02:01:31,200 --> 02:01:35,200
There is no concept of that in Azure Files, nor is there a change notification capability.

1409
02:01:35,680 --> 02:01:40,480
So, while when there's a change made here, it's easy to just go and replicate it to Azure.

1410
02:01:41,280 --> 02:01:43,360
There's no such concept in Azure.

1411
02:01:44,000 --> 02:01:46,240
So what I have to do is it has a job.

1412
02:01:46,640 --> 02:01:53,560
So there's a change detection job that runs periodically, and it does a list operations of the share, finds the changes, and will then send it down.

1413
02:01:53,560 --> 02:02:01,440
So you realize that there could be a little bit of a potential if I originate a change up here, it could introduce a little bit of a delay to that replication.

1414
02:02:01,600 --> 02:02:06,720
So just something to bear in mind as I think about those capabilities.

1415
02:02:07,600 --> 02:02:08,000
Okay.

1416
02:02:09,920 --> 02:02:10,960
A newer service,

1417
02:02:12,000 --> 02:02:13,520
Azure Elastic SAN.

1418
02:02:14,640 --> 02:02:17,480
Now, this is a block storage solution.

1419
02:02:17,480 --> 02:02:34,800
Now, remember, block means the client, whatever it's connecting to this, sees a disk, and it's then responsible for interacting with directly the blocks on it and having a various file system it's managing on top of that, compared to a file base where it talks to an API and just sees files and folders.

1420
02:02:35,360 --> 02:02:37,040
And what it's leveraging is iSCSI.

1421
02:02:37,440 --> 02:02:44,720
So iSCSI communicates over the network, so it doesn't require any special virtual hardware like it would need if it was using fibre channel.

1422
02:02:46,000 --> 02:02:47,840
And iSCSI is super common.

1423
02:02:48,000 --> 02:02:50,720
Like nearly any client can talk to iSCSI.

1424
02:02:51,280 --> 02:02:56,440
But a big focus here for Azure Elastic SAN is things like Azure VMware Solution, where I want some external storage.

1425
02:02:56,440 --> 02:02:57,920
I don't want to use the virtual SAN.

1426
02:02:58,240 --> 02:02:59,680
Azure Container Storage.

1427
02:03:00,960 --> 02:03:03,280
It is built on regular Azure storage.

1428
02:03:03,520 --> 02:03:06,080
This is not some storage appliance that they've bought.

1429
02:03:06,240 --> 02:03:08,480
It's running on Azure storage.

1430
02:03:09,160 --> 02:03:12,400
And so when I create an instance, it can be LRS or ZRS.

1431
02:03:12,480 --> 02:03:14,400
If we go and look for a second.

1432
02:03:15,440 --> 02:03:30,240
So if I actually go and look at Elastic Sans and I want to create one, you'll see what I specify is a region just like everything else I ever want to create in Azure.

1433
02:03:31,600 --> 02:03:33,040
And then I can pick the redundancy.

1434
02:03:33,040 --> 02:03:34,720
So is it LRS or ZRS?

1435
02:03:35,160 --> 02:03:42,480
And you'll see this idea of base units, which have an associated amount of IOPS and bandwidth throughput.

1436
02:03:42,800 --> 02:03:49,360
And then you just have these base capacity units that don't have any associated IOPS, but they would increase the capacity.

1437
02:03:49,840 --> 02:03:53,440
So I get those two kind of building blocks I can leverage.

1438
02:03:55,280 --> 02:03:59,680
So you have the base units and capacity units.

1439
02:04:00,040 --> 02:04:02,000
And then I create volume groups and volumes.

1440
02:04:02,280 --> 02:04:05,200
And then I would go and connect to it via iSCSI.

1441
02:04:06,080 --> 02:04:11,280
So let's talk about our Azure Elastic SAN.

1442
02:04:19,180 --> 02:04:21,420
So again, it's built on Azure Storage.

1443
02:04:21,980 --> 02:04:23,420
It's going to be LRS.

1444
02:04:23,420 --> 02:04:24,380
Let's use a different color.

1445
02:04:24,380 --> 02:04:25,100
It's hard to see.

1446
02:04:25,860 --> 02:04:30,780
LRS or ZRS for the redundancy of the data.

1447
02:04:31,340 --> 02:04:34,140
I buy a certain number of base units.

1448
02:04:34,720 --> 02:04:47,760
The base unit, remember, gives me capacity, and then an associated number of IOPS and throughput, but I can also just do capacity units.

1449
02:04:49,600 --> 02:04:55,040
So maybe I've hit the performance I need, but I need a bit more storage space, so that is just capacity.

1450
02:04:58,560 --> 02:05:03,440
Once I create the Azure Elastic Soundlite, add those base units and capacity units within there,

1451
02:05:04,000 --> 02:05:06,400
I create one or more volume groups.

1452
02:05:09,600 --> 02:05:16,640
And a volume group is where I define things like the network connectivity that I want.

1453
02:05:16,960 --> 02:05:24,160
So it's really just a network and security boundary.

1454
02:05:25,120 --> 02:05:30,560
So on the network, I could say things like, hey, which VNets is this going to go and integrate with?

1455
02:05:30,560 --> 02:05:32,080
Do I need private endpoints?

1456
02:05:32,560 --> 02:05:38,160
On a security, I could say, do I want a platform managed key or customer managed key, for example.

1457
02:05:38,480 --> 02:05:41,440
So this is a boundary for those configurations.

1458
02:05:42,000 --> 02:05:53,200
And then within the volume group, I then go and create N number of volumes, which is just, hey, I pick the capacity for this particular volume.

1459
02:05:54,560 --> 02:05:59,520
And then the IOPS and the throughput is going to be associated based on that capacity.

1460
02:05:59,840 --> 02:06:06,720
And then this is what the various clients would go and connect to via iSCSI.

1461
02:06:08,080 --> 02:06:12,800
And because it's iSCSI, I could have multiple different servers talking to the same volume.

1462
02:06:13,040 --> 02:06:16,000
And if it was Windows, they could use it as cluster shared volumes, for example.

1463
02:06:16,920 --> 02:06:24,880
And so it's a very cost-efficient type of storage that can be now leveraged from many different workloads.

1464
02:06:25,360 --> 02:06:27,440
And because it's iSCSI, it's gone over the network.

1465
02:06:27,440 --> 02:06:28,960
So for my virtual machine,

1466
02:06:29,520 --> 02:06:34,480
This counts against my network performance, not my storage performance.

1467
02:06:34,640 --> 02:06:37,520
So that's an important thing to understand there.

1468
02:06:39,440 --> 02:06:41,360
And then there's Azure NetApp Files.

1469
02:06:42,480 --> 02:06:49,920
Now I said before that Azure does not use SANS, doesn't have those anywhere, except for one place.

1470
02:06:50,720 --> 02:06:52,880
Well, this is the one place.

1471
02:06:53,200 --> 02:06:58,960
So Azure NetApp files, it actually has NetApp filers sitting in Azure data centers.

1472
02:06:59,200 --> 02:07:00,640
They create, it's a good partnership.

1473
02:07:00,720 --> 02:07:03,360
They've got a resource provider, so it's available via ARM.

1474
02:07:03,840 --> 02:07:09,920
And hey, I can now go and create these Azure NetApp file services in Azure.

1475
02:07:10,480 --> 02:07:21,680
And this is maybe a good use case where if I want some kind of maybe management consistency with what I'm used to on-prem, I need a super high set of performance that I just can't achieve with regular Azure.

1476
02:07:22,560 --> 02:07:28,400
And it provides different performance tiers depending on what I really need.

1477
02:07:28,960 --> 02:07:33,840
So if I think with Azure NetApp Files, let's go over here.

1478
02:07:34,800 --> 02:07:36,960
So we've got Azure NetApp Files.

1479
02:07:37,360 --> 02:07:40,560
So the structure here is I create an Azure NetApp Files account.

1480
02:07:40,560 --> 02:07:43,840
Now that exists within a certain region.

1481
02:07:46,560 --> 02:07:51,280
And then what I'm going to do is create one or more capacity pools.

1482
02:07:54,240 --> 02:07:57,640
So I can have N number of those within that particular account.

1483
02:07:58,080 --> 02:08:07,200
Now the capacity pool has a certain amount of capacity, the amount of storage it's going to have, but then it has something called a service level.

1484
02:08:10,080 --> 02:08:20,360
Now that service level can be standard, it can be premium, or it can be ultra.

1485
02:08:22,200 --> 02:08:28,080
And really just this corresponds to the performance I'm going to get based on the capacity I provision.

1486
02:08:28,320 --> 02:08:34,560
So with standard, I'm going to get 16 megabytes per second per tebibyte.

1487
02:08:36,080 --> 02:08:41,720
With premium, I get 64, and with ultra, I get 128.

1488
02:08:42,640 --> 02:08:47,600
Now, something interesting they've actually done here is if these are the three

1489
02:08:48,320 --> 02:08:54,800
sort of service levels they have, and there's no particular IOPS limit, they've added something called the call access.

1490
02:08:55,200 --> 02:08:57,120
This isn't like when you're groovy or anything.

1491
02:08:57,440 --> 02:08:58,160
Fonzie joke.

1492
02:09:00,160 --> 02:09:04,000
Imagine I have cold data across any of these different tiers.

1493
02:09:04,840 --> 02:09:09,840
And this cold data, I specify the number of days since it's been accessed.

1494
02:09:09,840 --> 02:09:13,600
This, I think, could be between 2 and 183 days.

1495
02:09:14,720 --> 02:09:17,520
So it's tracking how cold the data is getting.

1496
02:09:18,040 --> 02:09:20,480
And then it starts to package up this cold data again.

1497
02:09:20,480 --> 02:09:24,240
It works on any of these into these four MB objects.

1498
02:09:24,640 --> 02:09:26,960
And then it goes and sticks it in an Azure storage account.

1499
02:09:29,840 --> 02:09:30,560
Because it's cheaper.

1500
02:09:32,880 --> 02:09:35,120
And that becomes this cold access.

1501
02:09:38,240 --> 02:09:43,920
And then I can control, hey, if that happens, does it go and pull it back?

1502
02:09:45,320 --> 02:09:46,640
And I have that capability.

1503
02:09:48,240 --> 02:09:52,320
I pay for the capacity I'm provisioning on these things.

1504
02:09:53,200 --> 02:09:58,400
I think I can dynamically increase and decrease the volumes.

1505
02:09:58,480 --> 02:10:03,840
I think 50 gigabytes is the smallest volume I can possibly have.

1506
02:10:04,600 --> 02:10:06,440
And so again, I've got the capacity pool.

1507
02:10:06,440 --> 02:10:12,320
And then from the capacity pool, I'm just going to go ahead and create volumes off of this.

1508
02:10:13,120 --> 02:10:14,960
And that just has a size.

1509
02:10:16,120 --> 02:10:34,240
a protocol, so this supports SMB, NFS, or Joule, so it can actually be both of them, but the volume is 50 gigabytes up to 100 tebibytes, or it's then called a large volume, I think it's up to 1 tebibyte, or maybe even 2 tebibytes with special things.

1510
02:10:34,560 --> 02:10:36,400
These change a lot with Azure NetApp files.

1511
02:10:36,400 --> 02:10:39,200
They reduce the minimums a lot and they increase the maximums a lot.

1512
02:10:39,560 --> 02:10:45,960
So you'd want to just go and honestly check the documentation, see what the actual capability is at this moment in time.

1513
02:10:46,040 --> 02:10:46,320
time.

1514
02:10:47,680 --> 02:10:52,400
But then for a particular volume, you hook it into a particular subnet.

1515
02:10:53,040 --> 02:10:55,440
So you're going to have your virtual network.

1516
02:10:57,520 --> 02:11:03,440
You're going to delegate a particular subnet to Azure NetApp files.

1517
02:11:04,000 --> 02:11:07,560
And that's how you can go and talk to it.

1518
02:11:07,560 --> 02:11:11,600
does have encryption in transit for NFS, but it's Kerberos integration.

1519
02:11:11,600 --> 02:11:12,920
Obviously, it's encrypted at rest.

1520
02:11:12,920 --> 02:11:14,640
It has all of those capabilities.

1521
02:11:15,520 --> 02:11:17,280
But yes, it uses that delegated subnet.

1522
02:11:20,720 --> 02:11:22,960
And it does have cross-region replication.

1523
02:11:24,000 --> 02:11:26,920
So it has a lot of different pairs actually.

1524
02:11:26,920 --> 02:11:31,920
If we look at their pairings, it's not just based on the standard Azure pairings.

1525
02:11:32,080 --> 02:11:37,280
So there's the regular Azure regional pairings that it supports, but it has non-standard pairings.

1526
02:11:37,600 --> 02:11:41,600
So I can go in and say, well, these are the particular pairings I need.

1527
02:11:41,920 --> 02:11:46,760
based on the particular functions or the capabilities that I have in my environment.

1528
02:11:46,800 --> 02:11:52,120
So I get a lot of nice flexibility into exactly what I want.

1529
02:11:52,640 --> 02:11:54,640
So there we go.

1530
02:11:57,120 --> 02:12:00,320
So those are the main storage capabilities.

1531
02:12:00,800 --> 02:12:05,680
Now we'll talk a lot more about this when we actually talk about virtual machines and some other services.

1532
02:12:06,480 --> 02:12:10,240
But one of the big things is we have this concept of managed disks.

1533
02:12:12,720 --> 02:12:16,480
This, as the name suggests, is a managed disk experience.

1534
02:12:16,800 --> 02:12:19,240
It's abstracting away the storage account.

1535
02:12:19,240 --> 02:12:29,200
I think I mentioned before, in the oldie days, so the old days with a virtual machine, what would actually happen is we would have a storage account.

1536
02:12:33,400 --> 02:12:39,360
Remember, a storage account had certain capabilities in terms of IOPS and throughput.

1537
02:12:39,880 --> 02:12:45,200
On the storage account, we would create a page BLOB, and that's what the VM would use.

1538
02:12:46,160 --> 02:12:50,880
So what's happening here is it's basically an abstraction.

1539
02:12:51,760 --> 02:12:52,960
There's still a storage account.

1540
02:12:52,960 --> 02:12:54,080
There's still a page BLOB.

1541
02:12:54,480 --> 02:12:55,600
We just don't see it.

1542
02:12:55,760 --> 02:13:03,440
You only see the storage account if you try and do an import-export, where you get a shared access signature to do that behavior, and then you see the storage account name.

1543
02:13:03,520 --> 02:13:05,120
But it's completely managed for you.

1544
02:13:05,440 --> 02:13:06,960
What I now see

1545
02:13:07,920 --> 02:13:12,160
is this nice managed disk thing.

1546
02:13:14,720 --> 02:13:17,680
So this is all abstracted away.

1547
02:13:17,680 --> 02:13:21,760
I don't have to worry about the limits of a storage account or thinking about a storage account.

1548
02:13:22,160 --> 02:13:23,600
It's just all done for me.

1549
02:13:24,640 --> 02:13:32,040
And this is going to be used by virtual machines, but then AKS uses virtual machine scale sets and then plug-ins, other things.

1550
02:13:32,040 --> 02:13:35,200
So many things will use this concept of a managed disk.

1551
02:13:36,960 --> 02:13:38,880
So I don't worry about a storage count at all.

1552
02:13:40,000 --> 02:13:45,760
Disks and snapshots, point in time, delta-based storage are just ARM-based resources.

1553
02:13:45,760 --> 02:13:49,440
They're first class citizens of Azure.

1554
02:13:50,640 --> 02:13:53,280
Now, there are many different SKUs available of them.

1555
02:13:54,480 --> 02:14:04,160
And the performance increases, the latency decreases as I kind of move up all of the different offerings from standard hard disk drive to, let's just draw these out.

1556
02:14:05,080 --> 02:14:16,720
So when I think about managed disk, the biggest configuration I do is I do pick a capacity, but the capacity is of a certain SKU.

1557
02:14:16,720 --> 02:14:23,520
So yes, there's going to be a certain size by picking a certain specific SKU name, but it's of a certain SKU.

1558
02:14:24,160 --> 02:14:29,920
So at the lowest level, we have standard hard disk drive.

1559
02:14:31,040 --> 02:14:33,040
Then we have a standard

1560
02:14:35,120 --> 02:14:43,760
SSD, then we have a premium SSD V1.

1561
02:14:45,760 --> 02:14:54,880
For these three, what we're actually, now you always here pay for the capacity provisioned, never the capacity used.

1562
02:14:55,440 --> 02:15:01,040
So here, it's the capacity provisioned, which is the size of the disk.

1563
02:15:01,880 --> 02:15:02,120
Right?

1564
02:15:02,120 --> 02:15:03,120
That's driving it.

1565
02:15:03,280 --> 02:15:05,120
So that's what I pay for.

1566
02:15:05,760 --> 02:15:12,480
And then I get an associated amount of IOPS and throughput based on the size of the disk.

1567
02:15:13,440 --> 02:15:14,480
Makes total sense.

1568
02:15:15,040 --> 02:15:19,600
Now, one of the other things you can do is you can increase the size of disks, but you can't shrink a disk.

1569
02:15:19,920 --> 02:15:30,360
So with the premium SSD V1, another nice capability it has is I can actually change the performance tier

1570
02:15:31,920 --> 02:15:33,840
separately from the capacity.

1571
02:15:34,640 --> 02:15:37,920
So imagine I need a higher performance for maybe a short amount of time.

1572
02:15:39,120 --> 02:15:40,840
I can increase the performance tier.

1573
02:15:40,880 --> 02:15:42,240
It won't grow the disk.

1574
02:15:42,720 --> 02:15:46,480
I'll pay for the higher size, but it won't actually increase the size.

1575
02:15:46,800 --> 02:15:53,200
But I get the performance characteristics of what would come with the higher skew disk.

1576
02:15:53,520 --> 02:15:56,720
So I can change the performance tier as I may need to.

1577
02:15:57,680 --> 02:16:00,080
If we go back to the slide, do I have the pricing?

1578
02:16:00,080 --> 02:16:01,360
Let's click on this for a second.

1579
02:16:02,800 --> 02:16:04,400
So this makes more sense.

1580
02:16:04,400 --> 02:16:15,920
If we look at the pricing for premium SSD, you're basically paying for, I don't want the V2.

1581
02:16:18,240 --> 02:16:18,560
There we go.

1582
02:16:19,680 --> 02:16:24,720
So I pay for a disk size and I get an associated performance.

1583
02:16:29,600 --> 02:16:31,840
So I get these different performance characteristics.

1584
02:16:36,000 --> 02:16:38,080
And they go up as the disk gets bigger.

1585
02:16:38,480 --> 02:16:46,000
So what I might say is, well, look, I only want a 512 gig disk, but I need the higher performance.

1586
02:16:46,320 --> 02:16:50,240
So I could say I want the performance characteristics of the P40,

1587
02:16:50,880 --> 02:16:53,280
but it won't increase the disk to two tebibytes.

1588
02:16:53,280 --> 02:16:59,200
The disk would stay 512, but I'll get the higher set of performance that gets associated with it.

1589
02:16:59,440 --> 02:17:02,880
So that's where I might use that performance tier capability.

1590
02:17:03,520 --> 02:17:05,360
The other thing you'll notice is we get bursting.

1591
02:17:06,960 --> 02:17:15,280
So I can burst up to a higher performance for a limited amount of time, and it's free for some of the tiers.

1592
02:17:15,280 --> 02:17:18,800
So A P20, I get a free bucket of burst capability.

1593
02:17:20,000 --> 02:17:23,840
the P30 and above, I have to pay for those buckets of burst capability.

1594
02:17:24,000 --> 02:17:27,360
So there's different options if I need to get some higher performance.

1595
02:17:27,920 --> 02:17:33,280
The standard SSD, I think it's the one tebibyte and smaller, they have free bursting as well.

1596
02:17:35,520 --> 02:17:36,800
But then they changed the model.

1597
02:17:38,480 --> 02:17:47,760
So then we have a premium SSD V2.

1598
02:17:48,640 --> 02:18:11,680
And we also have an Ultra Disk, so with both of these, what I actually pay for is the capacity, the amount of IOPS I want, and the amount of throughput I want, and these are dynamic, so I can change it as I need to.

1599
02:18:13,080 --> 02:18:24,720
And so now I have more flexibility because I can turn the dials to say, hey, I need this amount of capacity, I need this amount of IPS, I need this amount of throughput, and I can really just kind of tweak those things as I need to do it.

1600
02:18:25,760 --> 02:18:29,840
And that obviously flexibility is becoming more and more common.

1601
02:18:30,120 --> 02:18:37,040
And the whole point here is the latency, the time it takes for an operation, the premium SSD is sub-millisecond.

1602
02:18:37,600 --> 02:18:40,240
The ultra disk, I think, is sub-half millisecond.

1603
02:18:40,800 --> 02:18:44,840
So the latency gets lower and lower as I move through these tiers.

1604
02:18:44,840 --> 02:18:49,760
So not only does the performance increase with these, the latency gets lower and lower.

1605
02:18:50,160 --> 02:18:55,360
Because of that, all of these, none of them are geo-redundant.

1606
02:18:55,680 --> 02:18:57,920
Like I never get geo-redundant for any of these.

1607
02:18:58,880 --> 02:19:04,120
But with these, because the latency is so low, I only can do LRS.

1608
02:19:04,120 --> 02:19:06,560
I can't even do ZRS for those because

1609
02:19:06,880 --> 02:19:11,920
the time between availability zones would start to jeopardize the performance of the disk.

1610
02:19:12,640 --> 02:19:19,960
So price based on the provisioned, not the consumed, you can dynamically increase the size of the data disks.

1611
02:19:20,160 --> 02:19:21,600
not Ultra and Premium V2.

1612
02:19:21,760 --> 02:19:24,240
Always check things change with capabilities.

1613
02:19:24,480 --> 02:19:32,480
Now, obviously, if I make a disk bigger, I then would need to, in the operating system that's talking to it, go and increase the volumes that's actually using that.

1614
02:19:33,200 --> 02:19:34,400
There's no GRS option.

1615
02:19:35,120 --> 02:19:38,240
Premium, SSD V2 and Ultra only have LRS.

1616
02:19:39,600 --> 02:19:51,200
If you're using availability sets, which hopefully you're not because we're trying to move to availability zones, but you can align the managed disk to different storage clusters based on different fault domain of the VM we talked about in the resiliency module.

1617
02:19:52,320 --> 02:19:58,320
But all of the types of SSD and ultra disks have a max shares property.

1618
02:19:58,800 --> 02:20:04,560
So this enables you to have multiple VMs connecting to the same managed disk.

1619
02:20:04,960 --> 02:20:16,480
So that's really useful if I want some sort of shared SCSI persistent reservation capability of Windows or Linux cluster, and I want the same capability there to use the same disk.

1620
02:20:17,280 --> 02:20:18,960
I can set my own encryption.

1621
02:20:18,960 --> 02:20:21,280
We use something called a disk encryption set.

1622
02:20:21,680 --> 02:20:30,320
So if I think about this managed disk, imagine now I have my Azure Key Vault with my key in it.

1623
02:20:31,840 --> 02:20:34,480
So what we're going to do is create something called disk encryption set.

1624
02:20:34,480 --> 02:20:40,320
And we're saying this disk encryption set uses that particular key.

1625
02:20:41,840 --> 02:20:43,280
So it's a customer managed key.

1626
02:20:43,400 --> 02:20:49,040
And then I place managed disks into a particular disk encryption set.

1627
02:20:49,280 --> 02:20:56,200
Then they're going to use that key to unwrap the encryption material that is then actually used to

1628
02:20:56,240 --> 02:20:57,840
get to the bits on the disk.

1629
02:20:58,000 --> 02:21:00,560
So you do have some nice control if you need to.

1630
02:21:00,960 --> 02:21:03,680
I can use my own encryption key on that.

1631
02:21:04,160 --> 02:21:06,560
There's also a host encryption capability.

1632
02:21:06,880 --> 02:21:16,640
What that would do is it would encrypt any local cache, any temp disks, the data in transit between the host the VM is on and the underlying storage.

1633
02:21:17,280 --> 02:21:19,440
I can also do a cross-tenant custom managed key.

1634
02:21:19,840 --> 02:21:25,680
So the key could be in a key vault in a different entra tenant from where I've actually had my managed disk.

1635
02:21:26,080 --> 02:21:33,360
That would be really useful in a scenario where, again, I'm that SAS type provider and I've got storage for maybe another company.

1636
02:21:35,920 --> 02:21:37,720
So virtual machine storage.

1637
02:21:37,720 --> 02:21:46,240
And remember, when I create a virtual machine, when I start my VM, it's put on a certain host within a certain data center.

1638
02:21:47,040 --> 02:21:52,720
It's using a Hyper-V hypervisor and it gets the various CPU and memory that's associated with that VM.

1639
02:21:53,680 --> 02:22:01,280
Now, the VM has an operating system disk that's normally durable, so it's going to be a managed disk on a hidden storage account.

1640
02:22:02,560 --> 02:22:06,720
We may have some workloads, though, where I actually don't care about the operating system disk.

1641
02:22:07,120 --> 02:22:09,280
Maybe I create and delete them as needed.

1642
02:22:09,280 --> 02:22:17,040
It might be a volume VM shadow set that, sorry, scale set, I'm thinking of volume shadow service.

1643
02:22:17,200 --> 02:22:22,160
So it's a virtual machine scale set where I create and delete them as my workload changes.

1644
02:22:22,480 --> 02:22:23,720
There's nothing special about them.

1645
02:22:23,720 --> 02:22:24,560
They're tin soldiers.

1646
02:22:24,560 --> 02:22:26,080
I stand them up, I knock them down.

1647
02:22:26,400 --> 02:22:27,760
So I actually don't care about the OS.

1648
02:22:27,760 --> 02:22:30,000
It's not a unique snowflake I care about.

1649
02:22:30,720 --> 02:22:34,400
So one of the options we can actually do is use ephemeral storage.

1650
02:22:34,720 --> 02:22:42,880
Providing the VM has enough cache space or temp space, it will use that to use for its operating system disk.

1651
02:22:42,880 --> 02:22:45,120
So there's no managed disk required.

1652
02:22:45,600 --> 02:22:49,760
That means I'm saving the cost of the managed disk, but it's also really high performance.

1653
02:22:50,080 --> 02:22:54,720
Consider the scenario here that, okay, so I have a host.

1654
02:22:57,720 --> 02:23:03,680
Remember that host has some local amount of storage on it, some SSD.

1655
02:23:04,880 --> 02:23:08,400
When I start my VM, it gets created on a certain host.

1656
02:23:09,280 --> 02:23:11,680
was that no latency between these things.

1657
02:23:11,840 --> 02:23:20,400
So if I can use this to store my OS, it's going to be really high performant and a really, really low latency.

1658
02:23:21,040 --> 02:23:27,600
So realize some workloads, especially those VM scale set based ones, could be my AKS, my auto scale in the cluster.

1659
02:23:28,320 --> 02:23:31,520
If I don't care about the OS state, which I probably don't,

1660
02:23:32,320 --> 02:23:35,200
Using ephemeral storage will save me money on the managed disk.

1661
02:23:35,320 --> 02:23:38,880
It will get created that much faster, and I'll get a higher performance.

1662
02:23:39,200 --> 02:23:41,760
So that's always an option available to me.

1663
02:23:42,400 --> 02:23:47,000
Now, normally, most VMs have a temporary drive.

1664
02:23:47,000 --> 02:23:53,520
This will be D or dev SDB 1 by default on Linux, but it's non-persistent.

1665
02:23:55,040 --> 02:23:59,840
If it has temporary storage, it has the little D modifier as part of it.

1666
02:24:00,000 --> 02:24:01,440
Windows puts the page file on it.

1667
02:24:01,440 --> 02:24:08,240
I could use it as a scratch drive, but you don't put anything you care about on it because it could just disappear at any moment in time.

1668
02:24:09,520 --> 02:24:14,880
If, because it gets created and deleted, created, deleted every time I start or stop the VM.

1669
02:24:15,360 --> 02:24:24,960
If I need a certain structure on it, maybe SQL was using it for a temp DB, I'd have to have some script running there to go and create whatever structure I need.

1670
02:24:25,440 --> 02:24:33,680
But ordinarily, what's going to happen is my virtual machine, well, it's going to attach to a managed disk, for example, for the operating system.

1671
02:24:36,640 --> 02:24:38,640
Maybe also I have some for data disks.

1672
02:24:39,600 --> 02:24:42,320
I can set the type of caching I require.

1673
02:24:42,560 --> 02:24:44,320
Maybe I don't want read-write caching.

1674
02:24:44,320 --> 02:24:45,760
Maybe I do want read-write caching.

1675
02:24:45,760 --> 02:24:46,960
Maybe I want read caching.

1676
02:24:47,360 --> 02:24:48,680
You have control of that.

1677
02:24:48,680 --> 02:24:58,480
And then if it's that D variant, what you'll also get is it will attach to this for my temp drive.

1678
02:24:59,120 --> 02:25:03,040
But again, if I shut down my VM, it disappears from this host.

1679
02:25:03,120 --> 02:25:04,400
This VHD gets deleted.

1680
02:25:04,800 --> 02:25:08,160
Do not put any data you care about on the temporary disk.

1681
02:25:08,480 --> 02:25:12,720
because **** it could just go and disappear at any time.

1682
02:25:13,200 --> 02:25:19,080
Some VM SKUs actually have NVME local storage as well, which is super high performant.

1683
02:25:19,200 --> 02:25:20,480
But again, it's not durable.

1684
02:25:20,720 --> 02:25:22,880
I mean, the L-series VMs have that.

1685
02:25:23,840 --> 02:25:29,120
For really new VMs, you can actually use NVME to talk to this local instead of SCSI.

1686
02:25:29,360 --> 02:25:31,440
So again, you get higher performance.

1687
02:25:31,680 --> 02:25:36,400
And you can even use it for, I think, the temp drive as well, for I think the V6 SKUs.

1688
02:25:38,080 --> 02:25:44,160
Something important to remember when I think of storage is the disk has its performance characteristics.

1689
02:25:44,640 --> 02:25:46,960
The disk has a certain amount of IOPS and throughput.

1690
02:25:47,120 --> 02:25:51,200
Now I could attach many, many disks to the virtual machine, which would increase the performance.

1691
02:25:51,760 --> 02:25:56,880
But the VM also has storage performance characteristics.

1692
02:25:57,200 --> 02:26:00,560
The number of IOPS it supports, the throughput it supports.

1693
02:26:00,880 --> 02:26:07,760
So just throwing disks at a VM, the VM may become the bottleneck because you're exceeding its capabilities.

1694
02:26:08,440 --> 02:26:10,920
If we go, oh, I can actually click this.

1695
02:26:10,920 --> 02:26:14,960
So this is going to show me the types of virtual machines.

1696
02:26:15,760 --> 02:26:17,120
These are naming conventions.

1697
02:26:17,120 --> 02:26:19,360
So this is the little D.

1698
02:26:19,760 --> 02:26:21,040
Hey, it's got a local disk.

1699
02:26:21,440 --> 02:26:28,320
But if I go and look at a particular virtual machine size, doesn't matter which one.

1700
02:26:31,600 --> 02:26:36,680
It will show me, so my local storage, but that doesn't have it, but remote.

1701
02:26:37,440 --> 02:26:40,000
It has a certain performance associated with it.

1702
02:26:40,480 --> 02:26:47,760
So if I just throw more and more disks at it, at a certain point, the VM would become the bottleneck, not the disk itself.

1703
02:26:47,760 --> 02:26:49,920
So you need to balance those two things.

1704
02:26:50,800 --> 02:26:56,160
VMs also have a certain number of NICs you can support and amount of network bandwidth they can support.

1705
02:26:56,720 --> 02:27:00,160
Now, why do I care about network bandwidth if I'm talking about storage?

1706
02:27:00,640 --> 02:27:06,960
Well, so the VM has its NIC and it has its capabilities.

1707
02:27:07,440 --> 02:27:16,160
If I'm talking to an SMB file share or an NFS file share or iSCSI, that goes over the network connection.

1708
02:27:16,640 --> 02:27:21,760
That's not using, in that case, my storage performance.

1709
02:27:22,080 --> 02:27:30,040
So make sure you remember those aspects as well, because that's a super, super important point when you're planning and sizing your workloads.

1710
02:27:30,040 --> 02:27:36,720
If you're doing a lot of SMB or NFS or iSCSI, then you care about the network performance of your virtual machine.

1711
02:27:37,840 --> 02:27:41,440
So you have additional disks, others have special types like NVME.

1712
02:27:42,560 --> 02:27:45,120
Remember, the VM has throughput limits as well.

1713
02:27:47,200 --> 02:27:49,360
And some VMs have boost capabilities.

1714
02:27:49,680 --> 02:27:53,120
so they can burst beyond their normal size things as well.

1715
02:27:54,080 --> 02:27:55,920
I'm not really going to go into a lot of detail about this.

1716
02:27:55,920 --> 02:27:57,720
It's there in the slides you can look on it.

1717
02:27:57,720 --> 02:28:04,880
But the whole point here is, and this gets a lot less likely these days with the capabilities of SSD v2 and Ultra Disk.

1718
02:28:05,360 --> 02:28:09,120
But some of the biggest VMs, I can have up to 64 disks on them.

1719
02:28:09,520 --> 02:28:14,000
Remember, in the OS, like Windows, I can use storage spaces to combine disks.

1720
02:28:14,480 --> 02:28:16,400
RAID sets can be a bit dodgy.

1721
02:28:16,400 --> 02:28:19,120
I generally wouldn't use a RAID set, use a storage space.

1722
02:28:19,600 --> 02:28:26,080
You don't need to use mirroring or parity because there's always 3 copies of the underlying disk anyway, remember.

1723
02:28:26,560 --> 02:28:29,520
So I don't need to do those things.

1724
02:28:29,800 --> 02:28:35,680
Things like SQL already use file groups to manage if there's multiple disks attached to it.

1725
02:28:37,040 --> 02:28:41,280
Multiple disks would give higher IOPS and throughput than one disk, maybe.

1726
02:28:41,760 --> 02:28:46,080
But honestly, I'm just coming down to the fact that with premium SSD v2 and ultra disk,

1727
02:28:46,560 --> 02:28:48,400
it's really unlikely you actually need this.

1728
02:28:48,800 --> 02:28:52,400
I just don't see a fantastic use case to want to get into this.

1729
02:28:53,440 --> 02:28:59,040
From a tooling perspective, so Azure Storage Explorer is a free tool you can just go and download.

1730
02:28:59,840 --> 02:29:06,320
I can use an account, I can use account, a key, I can use a shared access signature.

1731
02:29:06,960 --> 02:29:09,680
It works with all the different types of capabilities.

1732
02:29:10,080 --> 02:29:14,480
If you've kind of seen me use it, so if I go over to here,

1733
02:29:15,120 --> 02:29:18,240
You can see I can go and look at a particular subscription.

1734
02:29:18,480 --> 02:29:19,920
I can see all of my storage accounts.

1735
02:29:19,920 --> 02:29:21,120
I can see my disks.

1736
02:29:21,440 --> 02:29:23,280
I could go and browse around.

1737
02:29:24,560 --> 02:29:28,120
I can do various fantastic things within here.

1738
02:29:28,320 --> 02:29:31,400
I mean, you saw me do a lot of this stuff in the portal.

1739
02:29:31,400 --> 02:29:39,520
I can create shared access signatures or I can right click and I've got nice capabilities over here to do all of the capabilities.

1740
02:29:41,120 --> 02:29:42,560
But in the portal,

1741
02:29:44,960 --> 02:29:55,520
We go back over, when I'm looking at a storage account, storage account, there we go.

1742
02:29:56,960 --> 02:30:01,360
We have this nice little storage browser, which is basically a web version of it.

1743
02:30:02,640 --> 02:30:04,880
So I can do a lot of the similar things.

1744
02:30:05,760 --> 02:30:08,720
I can go and look at a particular container.

1745
02:30:08,800 --> 02:30:13,360
From the container, I can go and look at different...

1746
02:30:13,760 --> 02:30:15,840
capabilities within this thing.

1747
02:30:16,400 --> 02:30:18,000
I can see all my data.

1748
02:30:22,000 --> 02:30:23,760
I could look at file shares, queues.

1749
02:30:24,000 --> 02:30:30,880
So it's just a nice way to actually go and interact with the capabilities.

1750
02:30:33,040 --> 02:30:38,720
It's really easy to go and view it if you don't want to go and use an API and do those things directly.

1751
02:30:39,760 --> 02:30:42,640
One of the really great things this actually does

1752
02:30:43,600 --> 02:30:48,080
is though I can do something called server-side copying.

1753
02:30:48,480 --> 02:30:50,080
So imagine I had two storage accounts.

1754
02:30:51,520 --> 02:30:58,120
Ordinarily, if I'm a client and I'm copying, I read the data, so it downloads it from Azure, then it has to upload it to Azure.

1755
02:30:58,120 --> 02:31:00,600
So it's hairpinning via my client.

1756
02:31:01,520 --> 02:31:03,280
With server-side copying, it doesn't do that.

1757
02:31:04,000 --> 02:31:04,880
It just...

1758
02:31:05,760 --> 02:31:07,920
copies directly between the storage accounts.

1759
02:31:08,160 --> 02:31:09,760
So it's super high performance.

1760
02:31:09,920 --> 02:31:12,240
I'm not having to now worry about it coming via my client.

1761
02:31:12,480 --> 02:31:14,360
So it's a really, really good solution.

1762
02:31:14,360 --> 02:31:19,960
Also, when we talk about copying data, AZ Copy is a command line utility.

1763
02:31:19,960 --> 02:31:20,560
It's free.

1764
02:31:20,800 --> 02:31:26,000
It also uses server-to-server APIs, so it doesn't do that nasty hairpinning thing.

1765
02:31:27,240 --> 02:31:33,280
Depending on the number of CPUs I have in my machine, I can change the concurrencies of how many operations happen at the same time.

1766
02:31:33,680 --> 02:31:36,240
so it can speed up the overall capabilities.

1767
02:31:36,480 --> 02:31:40,000
It can use jobs to track the status of what I'm doing.

1768
02:31:40,320 --> 02:31:42,880
It's really good to migrate data.

1769
02:31:43,280 --> 02:31:59,280
So not only is it good for moving from on-prem to Azure, but I can do it from AWS S3 buckets, from Google Storage buckets to again migrate to Azure Storage, not from Azure Storage to those things, but certainly getting it into Azure Storage.

1770
02:31:59,520 --> 02:32:00,600
There's also a sync mode.

1771
02:32:01,680 --> 02:32:03,040
So the sync mode is really nice.

1772
02:32:03,360 --> 02:32:10,160
It will detect changes from my local storage and to kind of keep them in sync.

1773
02:32:10,800 --> 02:32:14,000
So that's a really nice capability to have there.

1774
02:32:15,760 --> 02:32:21,520
Now obviously there are other storage copy solutions like Azure Data Factory is really, really powerful.

1775
02:32:21,760 --> 02:32:23,440
There's cool stuff I can do there.

1776
02:32:25,440 --> 02:32:33,280
But I mean, this is a great way to keep, move lots of data between Azure from another cloud to Azure, keep things in sync.

1777
02:32:33,760 --> 02:32:35,600
There's also Azure Storage Mover.

1778
02:32:36,800 --> 02:32:42,240
So Azure Storage Mover helps me migrate from on-premises shares.

1779
02:32:42,240 --> 02:32:45,920
So it can be SMB, it can be NFS to Azure.

1780
02:32:46,640 --> 02:32:50,480
So for SMB 2.0 and above, it can migrate to an Azure file share.

1781
02:32:50,880 --> 02:32:54,720
For NFS 3 and 4, it can migrate to Azure Blob Container Storage.

1782
02:32:55,440 --> 02:32:58,200
It is a fully managed migration.

1783
02:32:58,200 --> 02:33:02,760
As an agent, you deploy onto your network that has line of sight to the source.

1784
02:33:02,760 --> 02:33:05,120
So it's basically a VM appliance you deploy down.

1785
02:33:05,600 --> 02:33:08,800
It only has to be able to speak to Azure via 443.

1786
02:33:09,920 --> 02:33:14,480
And what it's going to do is it will maintain everything it can about the data.

1787
02:33:14,480 --> 02:33:16,080
So for SMB, it maintains everything.

1788
02:33:16,560 --> 02:33:24,000
I get the full fidelity of all the metadata, any time stamps, the permissions, everything.

1789
02:33:24,480 --> 02:33:37,200
For NFS, an empty folder will get represented as an empty BLOB, and the metadata of that empty folder will be stored as custom metadata on the BLOB, and I can work with Azure Databox.

1790
02:33:38,400 --> 02:33:47,360
So, Azure Databox is an offline tool, so maybe my network connection is not good enough to support moving huge amounts of data into Azure.

1791
02:33:48,160 --> 02:33:54,960
So Azure Databox is an offline solution to move it, but then that takes a couple of days and stuff has changed.

1792
02:33:55,440 --> 02:34:04,560
Well, then Azure Storage Mover could replicate what had changed since that time, which brings me nicely to import and export.

1793
02:34:06,080 --> 02:34:07,720
I have lots of data.

1794
02:34:07,720 --> 02:34:10,560
I want to get into Azure or maybe out of Azure.

1795
02:34:12,640 --> 02:34:16,160
And so what this does is there's an Azure import export.

1796
02:34:16,160 --> 02:34:17,200
It's my disks.

1797
02:34:19,120 --> 02:34:24,000
2 1/2 inch disk SSDs, no USB drives, single job can have up to 10 disks.

1798
02:34:24,280 --> 02:34:31,600
I put my data on it and I send it into Azure and they put it into my storage account.

1799
02:34:33,840 --> 02:34:35,360
It's encrypted using BitLocker.

1800
02:34:36,640 --> 02:34:40,160
Azure Data Box disk is when Microsoft...

1801
02:34:40,640 --> 02:34:44,960
So when I say 2 1/2 inch SSD only, if it's an SSD, it's only a 2 1/2 inch disk.

1802
02:34:45,920 --> 02:34:46,800
But I do have choices.

1803
02:34:47,680 --> 02:34:50,680
Azure Data Box Disk is Azure provides the disks.

1804
02:34:50,680 --> 02:34:55,040
So they're going to give you between 1:00 and 5:00 SSDs, the 8 terabyte encrypted disks.

1805
02:34:55,680 --> 02:35:00,720
It'll be USB 3 connection to your system and you copy your data to it.

1806
02:35:01,880 --> 02:35:05,840
And then for much bigger jobs, there's an Azure Data Box.

1807
02:35:06,640 --> 02:35:08,160
So this is an appliance.

1808
02:35:08,400 --> 02:35:10,240
Now it comes in various sizes.

1809
02:35:10,240 --> 02:35:15,840
The original solutions with this 4U appliance that was 80 terabytes, something of usable space.

1810
02:35:16,480 --> 02:35:25,600
And there was a Databox Heavy, which was this 500 pound unit they would ship to you that I think was 770 terabytes of usable space.

1811
02:35:26,800 --> 02:35:30,400
So that was like a freight delivery, but obviously I could transport more data.

1812
02:35:31,040 --> 02:35:32,480
But it's now a new generation.

1813
02:35:32,480 --> 02:35:39,200
So there's 120 terabyte and a 525 terabyte version of it.

1814
02:35:39,920 --> 02:35:40,920
that I can use.

1815
02:35:40,920 --> 02:35:44,720
So again, this is an offline that gets delivered to my data center.

1816
02:35:44,880 --> 02:35:49,960
I copy the stuff to it, I ship it back to Azure, they bring it into my storage account.

1817
02:35:49,960 --> 02:35:55,280
And there's different capabilities depending on the solution for the source and the target that is supported.

1818
02:35:56,400 --> 02:36:03,560
And then just finishing up, just again, not an Azure storage feature at all, but data governance is super important.

1819
02:36:04,600 --> 02:36:10,640
When I think about data, for most organizations, it is the most important asset you have.

1820
02:36:11,440 --> 02:36:15,000
So I have to think about what is all of the data I have available to me.

1821
02:36:15,000 --> 02:36:24,160
And what's happening is as companies grow, they get more IT systems, they get more data, they do not have a good handle on the data.

1822
02:36:24,480 --> 02:36:26,160
Where is the data with PII?

1823
02:36:26,560 --> 02:36:28,640
How did it actually get into my system?

1824
02:36:28,840 --> 02:36:29,840
Where did it go?

1825
02:36:30,160 --> 02:36:31,440
So how do I find my data?

1826
02:36:31,440 --> 02:36:33,200
How do I classify the data?

1827
02:36:33,200 --> 02:36:35,520
Maybe with my own custom classifications?

1828
02:36:35,920 --> 02:36:37,360
How do I apply labels to it?

1829
02:36:37,520 --> 02:36:39,440
Then how do I use data loss prevention?

1830
02:36:39,520 --> 02:36:40,880
How do I use rights management?

1831
02:36:40,880 --> 02:36:41,920
How do I delete stuff?

1832
02:36:41,920 --> 02:36:45,200
Maybe I don't want to keep things that's older than a certain amount of time.

1833
02:36:45,840 --> 02:36:49,040
So how do I do all of these different capabilities?

1834
02:36:49,040 --> 02:36:50,240
And it's purview.

1835
02:36:50,880 --> 02:36:55,680
And just in case, I use a term rights management, and then I use the term data loss prevention.

1836
02:36:56,000 --> 02:37:00,160
Rights management is about controlling who can access and how they can use sensitive data.

1837
02:37:00,400 --> 02:37:03,440
Maybe I've been using encryption, maybe it's permissions, maybe it's expiration.

1838
02:37:04,080 --> 02:37:10,480
Data loss prevention is about monitoring and preventing sensitive data being shared in a way you don't want it to be shared.

1839
02:37:10,960 --> 02:37:15,840
So I'm restricting emails and content and maybe then alerting, maybe blocking.

1840
02:37:16,760 --> 02:37:21,760
And I want to be able to classify and control based on the sensitivity of the data.

1841
02:37:22,480 --> 02:37:28,080
So Purview is a data governance solution that I can use across my entire data estate.

1842
02:37:28,080 --> 02:37:28,920
It's not just Azure.

1843
02:37:28,920 --> 02:37:30,080
It's Azure and beyond.

1844
02:37:31,680 --> 02:37:33,600
There's A Purview.Microsoft.com site.

1845
02:37:34,160 --> 02:37:35,440
I run a discovery.

1846
02:37:35,600 --> 02:37:36,680
I find my data.

1847
02:37:36,800 --> 02:37:38,680
It identifies sensitive data.

1848
02:37:39,360 --> 02:37:45,600
I can apply sensitivity labels that can then use encryption and rights management and visual markings and way, way more.

1849
02:37:46,080 --> 02:37:53,800
There's hundreds of built-in classifications for this, or I can create my own custom classifications based on some projects, some regular expression I want.

1850
02:37:54,160 --> 02:37:59,120
There's a nice unified catalog, so I can easily discover and make data available.

1851
02:37:59,760 --> 02:38:04,160
And I can use policy to help control all of that access at scale.

1852
02:38:05,120 --> 02:38:08,320
So it's when I think about, hey, I've got this data in my organization.

1853
02:38:08,320 --> 02:38:11,280
AI is driving a lot of focus on this.

1854
02:38:11,760 --> 02:38:13,920
Purview is the solution for that.

1855
02:38:14,640 --> 02:38:15,360
And so that was it.

1856
02:38:16,400 --> 02:38:18,000
Lots covered in this one.

1857
02:38:18,040 --> 02:38:18,880
I hope it's useful.

1858
02:38:19,000 --> 02:38:20,320
Until next video, take care.
